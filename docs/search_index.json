[["index.html", "Géomatique avec R Chapitre 1 Préambule", " Géomatique avec R Timothée Giraud1 &amp; Hugues Pecout2 12 janvier 2023 Chapitre 1 Préambule Ce manuel est destiné tant aux utilisateurs de R souhaitant mettre en place des traitements de données spatiales qu’aux utilisateurs souhaitant utiliser R pour réaliser les taches qu’ils réalisent habituellement avec un SIG. Les principales étapes du traitement de l’information géographiques y sont abordées. L’accent est porté sur le traitement des données vectorielles mais une partie est tout de même dédiée aux données raster. Comment utiliser le manuel Le projet RStudio contenant l’ensemble des données utilisées dans le manuel est disponible ici. Une fois le dossier décompressé il est possible de tester l’ensemble des manipulations proposées dans le projet RStudio. Contribution et feedback Vous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le dépôt GitHub de ce document. Contexte Ce manuel a été initialement conçu pour accompagner le cours “Cartographie avec R” du Master 2 Géomatique, géodécisionnel, géomarketing et multimédia (G2M) de l’Université Paris 8 Vincennes - Saint-Denis. Un deuxième manuel centré sur la cartographie est disponible ici : Cartographie avec R. La version en ligne de ce document est sous licence Creative Commons Attribution-NonCommercial-ShareAlike 4.0. Pour citer le document : Giraud, T., &amp; Pecout, H. (2023). Géomatique avec R (Version 1.0.1). https://doi.org/10.5281/zenodo.7528145 @misc{Giraud_Geomatique_avec_R_2023, author = {Giraud, Timothée and Pecout, Hugues}, doi = {10.5281/zenodo.7528145}, title = {{Géomatique avec R}}, url = {https://rcarto.github.io/geomatique_avec_r/}, year = {2023} } UAR RIATE, CNRS, Université Paris Cité, F-75013 Paris, France↩︎ UMR Géographie-cités, CNRS, F-93322 Aubervilliers, France↩︎ "],["introductionx.html", "Chapitre 2 Introduction 2.1 Le spatial dans R : Historique et évolutions 2.2 Le package sf 2.3 Le package terra", " Chapitre 2 Introduction 2.1 Le spatial dans R : Historique et évolutions Historiquement, 4 packages permettent d’importer, de manipuler et de transformer les données spatiales : Le package rgdal (R. Bivand et al., 2018) qui est une interface entre R et les librairies GDAL (GDAL/OGR contributors, s. d.) et PROJ (PROJ contributors, 2021) permet d’importer et d’exporter les données spatiales (les shapefiles par exemple) et aussi de gérer les projections cartographiques Le package sp (Pebesma et Bivand, 2018) fournit des classes et méthodes pour les données spatiales vectorielles dans R. Il permet afficher des fond de cartes, d’inspecter une table attributaire etc. Le package rgeos (R. Bivand et Rundel, 2018) donne accès à la librairie d’opérations spatiales GEOS et rend donc disponible les opérations SIG classiques : calcul de surfaces ou de périmètres, calcul de distances, agrégations spatiales, zones tampons, intersections etc. Le package raster (Hijmans, 2021a) est dédié à l’import, la mabipulation et la modélisation des données raster. Aujourd’hui, les principaux développements concernants les données vectorielles se sont détachés des 3 anciens (sp, rgdal, rgeos) pour se reposer principalement sur le package sf ((Pebesma, 2018a), (Pebesma, 2018b)). Dans ce manuel nous nous appuierons exclusivement sur ce package pour manipuler les données vectorielles. Les packages stars (Pebesma, 2021) et terra(Hijmans, 2021b) sont venus quand à eux remplacer le package raster pour le traitement des données raster. Nous avons choisi d’utiliser ici le package terra pour sa proximité avec le package raster. En savoir plus sur l’écosysteme spatial de R : Progress in the R ecosystem for representing and handling spatial data (R. S. Bivand, 2020) CRAN Task View : Analysis of Spatial Data Liste de discussion : R Special Interest Group on using Geographical data and Mapping Manuel en anglais : Geocomputation with R (Lovelace et al., 2019) 2.2 Le package sf Le package sf a été publié fin 2016 par Edzer Pebesma (également auteur de sp). Son objectif est de combiner les fonctionnalités de sp, rgeos et rgdal dans un package unique plus ergonomique. Ce package propose des objets plus simples (suivant le standard simple feature) dont la manipulation est plus aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe et les opérateurs du tidyverse. sf utilise directement les librairies GDAL, GEOS et PROJ. From r-spatial.org Site web du package sf : Simple Features for R 2.3 Le package terra Le package terra a été publié début 2020 par Robert J. Hijmans (également auteur de raster). Son objectif est de proposer des méthodes de traitement et d’analyse de données rasrer. Ce package est très similaire au package raster; mais il propose plus de fonctionnalités, il est plus facile à utiliser et il est plus rapide. Site web du package terra : Spatial Data Science with R and “terra” References Bivand, R. S. (2020). Progress in the R ecosystem for representing and handling spatial data. Journal of Geographical Systems, 1‑32. Bivand, R., Keitt, T. et Rowlingson, B. (2018). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal Bivand, R. et Rundel, C. (2018). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos GDAL/OGR contributors. (s. d.). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://gdal.org Hijmans, R. J. (2021a). raster: Geographic Data Analysis and Modeling. https://CRAN.R-project.org/package=raster Hijmans, R. J. (2021b). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra Lovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation with R. CRC Press. https://geocompr.robinlovelace.net/ Pebesma, E. (2018a). sf: Simple Features for R. https://CRAN.R-project.org/package=sf Pebesma, E. (2018b). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal. https://journal.r-project.org/archive/2018/RJ-2018-009/index.html Pebesma, E. (2021). stars: Spatiotemporal Arrays, Raster and Vector Data Cubes. https://CRAN.R-project.org/package=stars Pebesma, E. et Bivand, R. (2018). sp: Classes and Methods for Spatial Data. https://CRAN.R-project.org/package=sp PROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/ "],["les-données-vectorielles.html", "Chapitre 3 Les données vectorielles 3.1 Format des objets spatiaux sf 3.2 Import et export de données 3.3 Affichage 3.4 Les systèmes de coordonnées 3.5 Sélection par attributs 3.6 Sélection spatiale 3.7 Opérations sur les géométries 3.8 Mesures 3.9 Exercices", " Chapitre 3 Les données vectorielles 3.1 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry). Ce format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet. Vignette décrivant le format simple feature : Simple Features for R 3.2 Import et export de données Les fonctions st_read() et st_write() permettent d’importer et d’exporter de nombreux types de fichiers. Les lignes suivantes importent la couche des communes du département du Lot situé dans le fichier geopackage lot46.gpkg. library(sf) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;) Reading layer `commune&#39; from data source `/home/tim/Documents/prj/geomatique_avec_r/data/lot46.gpkg&#39; using driver `GPKG&#39; Simple feature collection with 313 features and 12 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668 Projected CRS: RGF93 / Lambert-93 Les lignes suivantes exportent l’objet com dans un dossier data aux formats geopackage et shapefile. st_write(obj = com, dsn = &quot;data/com.gpkg&quot;, layer = &quot;commune&quot;, delete_layer = TRUE) Deleting layer `commune&#39; using driver `GPKG&#39; Writing layer `commune&#39; to data source `data/com.gpkg&#39; using driver `GPKG&#39; Writing 313 features with 12 fields and geometry type Multi Polygon. st_write(obj = com, &quot;data/com.shp&quot;, layer_options = &quot;ENCODING=UTF-8&quot;, delete_layer = TRUE) Deleting layer `com&#39; using driver `ESRI Shapefile&#39; Writing layer `com&#39; to data source `data/com.shp&#39; using driver `ESRI Shapefile&#39; options: ENCODING=UTF-8 Writing 313 features with 12 fields and geometry type Multi Polygon. 3.3 Affichage Aperçu des variables via les fonctions head() et plot(). head(com) Simple feature collection with 6 features and 12 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 556391.9 ymin: 6371852 xmax: 614866.5 ymax: 6418606 Projected CRS: RGF93 / Lambert-93 INSEE_COM NOM_COM STATUT POPULATION AGR_H AGR_F IND_H 1 46001 Albas Commune simple 522 4.978581 0.000000 4.936153 2 46002 Albiac Commune simple 67 0.000000 9.589041 0.000000 3 46003 Alvignac Commune simple 706 10.419682 0.000000 10.419682 4 46004 Anglars Commune simple 219 0.000000 0.000000 20.000000 5 46005 Anglars-Juillac Commune simple 329 4.894895 4.894895 4.894895 6 46006 Anglars-Nozac Commune simple 377 4.840849 0.000000 0.000000 IND_F BTP_H BTP_F TER_H TER_F geom 1 0.000000 9.957527 0.000000 44.917145 34.681799 MULTIPOLYGON (((559262 6371... 2 0.000000 4.794521 0.000000 4.794521 9.589041 MULTIPOLYGON (((605540.7 64... 3 5.209841 10.419682 0.000000 57.308249 78.147612 MULTIPOLYGON (((593707.7 64... 4 15.000000 10.000000 0.000000 20.000000 20.000000 MULTIPOLYGON (((613211.3 64... 5 0.000000 0.000000 0.000000 29.369369 29.369369 MULTIPOLYGON (((556744.9 63... 6 0.000000 9.681698 4.840849 43.567639 38.726790 MULTIPOLYGON (((576667.2 64... plot(com) Affichage de la géométrie uniquement. plot(st_geometry(com)) 3.4 Les systèmes de coordonnées 3.4.1 Consulter le système de coordonnées d’un objet La fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf. st_crs(com) Coordinate Reference System: User input: RGF93 / Lambert-93 wkt: PROJCRS[&quot;RGF93 / Lambert-93&quot;, BASEGEOGCRS[&quot;RGF93&quot;, DATUM[&quot;Reseau Geodesique Francais 1993&quot;, ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, LENGTHUNIT[&quot;metre&quot;,1]]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ID[&quot;EPSG&quot;,4171]], CONVERSION[&quot;Lambert-93&quot;, METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, ID[&quot;EPSG&quot;,9802]], PARAMETER[&quot;Latitude of false origin&quot;,46.5, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8821]], PARAMETER[&quot;Longitude of false origin&quot;,3, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8822]], PARAMETER[&quot;Latitude of 1st standard parallel&quot;,49, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8823]], PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,44, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8824]], PARAMETER[&quot;Easting at false origin&quot;,700000, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8826]], PARAMETER[&quot;Northing at false origin&quot;,6600000, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8827]]], CS[Cartesian,2], AXIS[&quot;easting (X)&quot;,east, ORDER[1], LENGTHUNIT[&quot;metre&quot;,1]], AXIS[&quot;northing (Y)&quot;,north, ORDER[2], LENGTHUNIT[&quot;metre&quot;,1]], USAGE[ SCOPE[&quot;Engineering survey, topographic mapping.&quot;], AREA[&quot;France - onshore and offshore, mainland and Corsica.&quot;], BBOX[41.15,-9.86,51.56,10.38]], ID[&quot;EPSG&quot;,2154]] 3.4.2 Modifier le système de coordonnées d’un objet La fonction st_transform() permet de change le système de coordonnées d’un objet sf, de le reprojeter. plot(st_geometry(com)) title(&quot;RGF93 / Lambert-93&quot;) com_reproj &lt;- st_transform(com, &quot;epsg:3035&quot;) plot(st_geometry(com_reproj)) title(&quot;ETRS89-extended / LAEA Europe&quot;) Le site Spatial Reference met à disposition les références de très nombreux systèmes de coordonnées. 3.5 Sélection par attributs Les objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame. # selection de ligne com[1:2, ] Simple feature collection with 2 features and 12 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204 Projected CRS: RGF93 / Lambert-93 INSEE_COM NOM_COM STATUT POPULATION AGR_H AGR_F IND_H IND_F BTP_H 1 46001 Albas Commune simple 522 4.978581 0.000000 4.936153 0 9.957527 2 46002 Albiac Commune simple 67 0.000000 9.589041 0.000000 0 4.794521 BTP_F TER_H TER_F geom 1 0 44.917145 34.681799 MULTIPOLYGON (((559262 6371... 2 0 4.794521 9.589041 MULTIPOLYGON (((605540.7 64... com[com$NOM_COM == &quot;Gramat&quot;, ] Simple feature collection with 1 feature and 12 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784 Projected CRS: RGF93 / Lambert-93 INSEE_COM NOM_COM STATUT POPULATION AGR_H AGR_F IND_H IND_F 119 46128 Gramat Commune simple 3468 10.19868 15.29802 122.3842 107.0862 BTP_H BTP_F TER_H TER_F geom 119 56.09275 0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64... # selection de colonnes com[com$NOM_COM == &quot;Gramat&quot;, 1:4] Simple feature collection with 1 feature and 4 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784 Projected CRS: RGF93 / Lambert-93 INSEE_COM NOM_COM STATUT POPULATION geom 119 46128 Gramat Commune simple 3468 MULTIPOLYGON (((594713.1 64... 3.6 Sélection spatiale 3.6.1 Intersections Sélection des routes intesectant la commune de Gramat. route &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;route&quot;, quiet = TRUE) gramat &lt;- com[com$NOM_COM == &quot;Gramat&quot;, ] inter &lt;- st_intersects(x = route, y = gramat, sparse = FALSE) head(inter) [,1] [1,] FALSE [2,] FALSE [3,] FALSE [4,] FALSE [5,] FALSE [6,] FALSE dim(inter) [1] 16096 1 L’objet inter est une matrice qui indique pour chacun des éléments de l’objet route (16096 éléments) si il intersecte chacun des élément de l’objet gramat (1 élément). La dimension de la matrice est donc bien 16096 lignes * 1 colonne. Notez l’utilisation du paramètre sparse = FALSE ici. Il est ensuite possible de créer une colonne à partir de cet objet : route$intersect_gramat &lt;- inter plot(st_geometry(gramat), col = &quot;lightblue&quot;) plot(st_geometry(route), add = TRUE) plot(st_geometry(route[route$intersect_gramat, ]), col = &quot;tomato&quot;, lwd = 2, add = TRUE) 3.6.1.1 Différence entre sparse = TRUE et sparse = FALSE sparse = TRUE inter &lt;- st_intersects(x = grid, y = pt, sparse = TRUE) inter Sparse geometry binary predicate list of length 4, where the predicate was `intersects&#39; 1: (empty) 2: 6, 7 3: 1, 4 4: 2, 3, 5, 8 sparse = FALSE inter &lt;- st_intersects(x = grid, y = pt, sparse = FALSE) rownames(inter) &lt;- grid$id colnames(inter) &lt;- pt$id inter a b c d e f g h 1 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 2 FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE 3 TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE 4 FALSE TRUE TRUE FALSE TRUE FALSE FALSE TRUE 3.6.2 Contains / Within Sélection des routes contenues dans la commune de Gramat. La fonctin st_within() fonctionne comme la fonction st_intersects() route$within_gramat &lt;- st_within(route, gramat, sparse = FALSE) plot(st_geometry(gramat), col = &quot;lightblue&quot;) plot(st_geometry(route), add = TRUE) plot(st_geometry(route[route$within_gramat, ]), col = &quot;tomato&quot;, lwd = 2, add = TRUE) 3.7 Opérations sur les géométries 3.7.1 Extraire des centroides com_c &lt;- st_centroid(com) plot(st_geometry(com)) plot(st_geometry(com_c), add = TRUE, cex = 1.2, col = &quot;red&quot;, pch = 20) 3.7.2 Agréger des polygones dep_46 &lt;- st_union(com) plot(st_geometry(com), col = &quot;lightblue&quot;) plot(st_geometry(dep_46), add = TRUE, lwd = 2, border = &quot;red&quot;) 3.7.3 Agréger des polygones en fonction d’une variable com_u &lt;- aggregate(x = com[,c(&quot;POPULATION&quot;)], by = list(STATUT = com$STATUT), FUN = &quot;sum&quot;) plot(com_u) 3.7.4 Construire une zone tampon gramat_b &lt;- st_buffer(x = gramat, dist = 5000) plot(st_geometry(gramat_b), col = &quot;lightblue&quot;, lwd=2, border = &quot;red&quot;) plot(st_geometry(gramat), add = TRUE, lwd = 2) 3.7.5 Réaliser une intersection En utilisant la fonction st_intersection() on va découper une couche par une autre. # création d&#39;une zone tampon autour du centroid de la commune de Gramat # en utilisant le pipe zone &lt;- st_geometry(gramat) |&gt; st_centroid() |&gt; st_buffer(10000) plot(st_geometry(com)) plot(zone, border = &quot;red&quot;, lwd = 2, add = TRUE) com_z &lt;- st_intersection(x = com, y = zone) plot(st_geometry(com)) plot(st_geometry(com_z), col=&quot;red&quot;, border=&quot;green&quot;, add=T) plot(st_geometry(com_z)) 3.7.6 Créer une grille régulière La fonction st_make_grid() permet de créer une grille régulière. La fonction produit un objet sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques. grid &lt;- st_make_grid(x = com, cellsize = 2500) grid &lt;- st_sf(ID = 1:length(grid), geom = grid) plot(st_geometry(grid), col = &quot;grey&quot;, border = &quot;white&quot;) plot(st_geometry(com), border = &quot;grey50&quot;, add = TRUE) 3.7.7 Compter des points dans un polygone # selection des carreaux de la grille qui intersectent le département inter &lt;- st_intersects(grid, dep_46, sparse = FALSE) grid &lt;- grid[inter, ] restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) plot(st_geometry(grid), col = &quot;grey&quot;, border = &quot;white&quot;) plot(st_geometry(restaurant), pch = 20, col = &quot;red&quot;, add = TRUE, cex = .2) inter &lt;- st_intersects(grid, restaurant, sparse = TRUE) length(inter) [1] 936 Ici nous utilisons l’argument sparse = TRUE. L’objet inter est une liste de la longueur de l’objet grid et chaque élément de la liste contient l’index des éléments de l’objet restaurant qu’il intersecte. Par exemple le carreau 795 intersecte les restaurants 2716 et 2718 : inter[795] [[1]] [1] 2716 2718 plot(st_geometry(grid[795, ])) plot(st_geometry(restaurant), add = T) plot(st_geometry(restaurant[c(2716, 2718), ]), col = &quot;red&quot;, pch = 19, add = TRUE) Pour compter le nombre de restaurants il suffit de parcourir la liste et de reporter la longueur de chacun de ces éléments. grid$nb_restaurant &lt;- sapply(X = inter, FUN = length) plot(grid[&quot;nb_restaurant&quot;]) 3.7.8 Aggréger les valeurs de points dans des polygones Dans cet exemple nous importons un fichier csv qui contient les données d’une grille de population. Une fois importé nous transformons le data.frame en objet sf. L’objectif est d’aggréger les valeur de ces points (les populations contenues dans le champ “Ind”) dans les communes du Lot. # Import du ficier pop_raw &lt;- read.csv(&quot;data/pop.csv&quot;) # ajout d&#39;un identifiant unique pop_raw$id &lt;- 1:nrow(pop_raw) # transformation en objet sf pop &lt;- st_as_sf(pop_raw, coords = c(&quot;x&quot;, &quot;y&quot;), crs = 3035) # gestion de la projection pop &lt;- st_transform(pop, st_crs(com)) # intersection inter &lt;- st_intersection(pop, com) inter Simple feature collection with 4350 features and 14 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 540316 ymin: 6347200 xmax: 637157.8 ymax: 6439117 Projected CRS: RGF93 / Lambert-93 First 10 features: Ind id INSEE_COM NOM_COM STATUT POPULATION AGR_H AGR_F IND_H IND_F 1069 3 1069 46001 Albas Commune simple 522 4.978581 0 4.936153 0 1070 7 1070 46001 Albas Commune simple 522 4.978581 0 4.936153 0 1129 11 1129 46001 Albas Commune simple 522 4.978581 0 4.936153 0 1130 9 1130 46001 Albas Commune simple 522 4.978581 0 4.936153 0 1131 13 1131 46001 Albas Commune simple 522 4.978581 0 4.936153 0 1189 18 1189 46001 Albas Commune simple 522 4.978581 0 4.936153 0 BTP_H BTP_F TER_H TER_F geometry 1069 9.957527 0 44.91714 34.6818 POINT (559462.5 6372439) 1070 9.957527 0 44.91714 34.6818 POINT (560457.4 6372534) 1129 9.957527 0 44.91714 34.6818 POINT (559374.1 6373435) 1130 9.957527 0 44.91714 34.6818 POINT (560369 6373530) 1131 9.957527 0 44.91714 34.6818 POINT (561363.8 6373625) 1189 9.957527 0 44.91714 34.6818 POINT (558290.8 6374337) [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 4 rows ] En utilisant la fonction st_intersection() nous rajoutons à chacun des point de la grille l’ensemble des information sur la commune dans lequel il se trouve. Nous pouvons ensuite utiliser la fonction aggregate() pour aggreger la population par communes. resultat &lt;- aggregate(x = list(pop_from_grid = inter$Ind), by = list(INSEE_COM = inter$INSEE_COM), FUN = &quot;sum&quot;) head(resultat) INSEE_COM pop_from_grid 1 46001 472.0 2 46002 79.0 3 46003 518.5 4 46004 144.5 5 46005 308.0 6 46006 345.0 On peut ensuite créer un nouvel objet avec ce resultat. com_res &lt;- merge(com, resultat, by = &quot;INSEE_COM&quot;, all.x = TRUE) com_res Simple feature collection with 313 features and 13 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668 Projected CRS: RGF93 / Lambert-93 First 10 features: INSEE_COM NOM_COM STATUT POPULATION AGR_H AGR_F IND_H 1 46001 Albas Commune simple 522 4.978581 0.000000 4.936153 2 46002 Albiac Commune simple 67 0.000000 9.589041 0.000000 3 46003 Alvignac Commune simple 706 10.419682 0.000000 10.419682 4 46004 Anglars Commune simple 219 0.000000 0.000000 20.000000 5 46005 Anglars-Juillac Commune simple 329 4.894895 4.894895 4.894895 6 46006 Anglars-Nozac Commune simple 377 4.840849 0.000000 0.000000 IND_F BTP_H BTP_F TER_H TER_F pop_from_grid 1 0.000000 9.957527 0.000000 44.917145 34.681799 472.0 2 0.000000 4.794521 0.000000 4.794521 9.589041 79.0 3 5.209841 10.419682 0.000000 57.308249 78.147612 518.5 4 15.000000 10.000000 0.000000 20.000000 20.000000 144.5 5 0.000000 0.000000 0.000000 29.369369 29.369369 308.0 6 0.000000 9.681698 4.840849 43.567639 38.726790 345.0 geometry 1 MULTIPOLYGON (((559262 6371... 2 MULTIPOLYGON (((605540.7 64... 3 MULTIPOLYGON (((593707.7 64... 4 MULTIPOLYGON (((613211.3 64... 5 MULTIPOLYGON (((556744.9 63... 6 MULTIPOLYGON (((576667.2 64... [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 4 rows ] 3.8 Mesures 3.8.1 Créer une matrice de distances Si le système de projection du jeu de données est renseigné les distances sont exprimées dans l’unité de mesure de la projection (en mètres le plus souvent). mat &lt;- st_distance(x = com_c, y = com_c) mat[1:5,1:5] Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.000 56784.77 54353.94 61166.42 3790.688 [2,] 56784.770 0.00 12454.29 7146.11 57288.103 [3,] 54353.942 12454.29 0.00 19388.52 54030.811 [4,] 61166.418 7146.11 19388.52 0.00 62016.141 [5,] 3790.688 57288.10 54030.81 62016.14 0.000 3.9 Exercices 3.9.1 Calculer le nombre de restaurants par communes Quelles communes ont plus de 10 restaurants et moins de 1000 habitants ? # Import des restaurants restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) # Calcul des intersections inter &lt;- st_intersects(x = com, y = restaurant, sparse = TRUE) # Parcourir la liste et compter le nombre d&quot;éléments com$nb_restaurant &lt;- sapply(X = inter, FUN = length) plot(com[&quot;nb_restaurant&quot;]) com_sel &lt;- com[com$nb_restaurant &gt;=10 &amp; com$POPULATION &lt;= 1000,] com_sel$NOM_COM [1] &quot;Rocamadour&quot; &quot;Saint-Cirq-Lapopie&quot; Créez une carte où vous afficherez toutes les communes en gris et les communes sélectionnées plus haut en rouge. plot(st_geometry(com), col = &quot;grey&quot;) plot(st_geometry(com_sel), col = &quot;red&quot;, add = TRUE) 3.9.2 Mesurer la densité du réseau routier par commune Intersecter les routes par les communes Découper les routes par les communes. Chaque segment de route récupère l’identifiant de la commune dans laquelle il se trouve. st_intersection() route_com &lt;- st_intersection(route, com[,&quot;INSEE_COM&quot;]) head(route_com, 1) Simple feature collection with 1 feature and 20 fields Geometry type: LINESTRING Dimension: XY Bounding box: xmin: 559100.3 ymin: 6372557 xmax: 561184 ymax: 6373301 Projected CRS: RGF93 / Lambert-93 ID VOCATION NB_CHAUSSE NB_VOIES ETAT ACCES POS_SOL 2572 BDCTRORO0000000021341618 Liaison locale 1 chaussée 1 voie Revêtu Libre Au sol RES_VERT SENS NB_VOIES_M NB_VOIES_D TOPONYME USAGE 2572 Non Double sens Sans objet Sans objet &lt;NA&gt; Logique et cartographique DATE NUM_ROUTE CLASS_ADM GEST_ROUTE intersect_gramat within_gramat INSEE_COM 2572 2021-05-07 &lt;NA&gt; Sans objet &lt;NA&gt; FALSE FALSE 46001 geom 2572 LINESTRING (559100.3 637330... Calculer la longueur des segments de route Rajouter une colonne longueur qui contient la longueur de chacun des segments. st_length() route_com$longueur &lt;- st_length(route_com) Calculer la longueur totale de route par commune Aggreger les segments de routes par commune pour obtenir des longueurs totales par commune. aggregate() longueur_total &lt;- aggregate(x = list(longueur = route_com$longueur), by = list(INSEE_COM = route_com$INSEE_COM), FUN = sum) Joindre les longueurs à la table des communes merge() com_dens &lt;- merge(x = com[,c(&#39;INSEE_COM&#39;, &quot;POPULATION&quot;)], y = longueur_total, by = &quot;INSEE_COM&quot;, all.x = TRUE) Calculer les superficies des communes st_area() com_dens$superficie &lt;- st_area(com_dens) Convertir les unités des différentes mesures units(…)&lt;-“km^2” units(com_dens$superficie) &lt;- &quot;km^2&quot; units(com_dens$longueur) &lt;- &quot;km&quot; Calculer les indicateurs Le premier est le rapport entre la longueur des routes et la population des communes. Le deuxième est le rapport entre la longueur des routes et la superficie des communes. com_dens$dens_pop &lt;- com_dens$longueur / com_dens$POPULATION plot(com_dens[&quot;dens_pop&quot;], main = &quot;km / hab&quot;) com_dens$dens_sup &lt;- com_dens$longueur / com_dens$superficie plot(com_dens[&quot;dens_sup&quot;], main = &quot;km / km²&quot;) "],["georéférencement.html", "Chapitre 4 Georéférencement 4.1 Géocoder des adresses 4.2 Transformer les données long/lat en objet sf 4.3 Digitalisation", " Chapitre 4 Georéférencement 4.1 Géocoder des adresses Plusieurs packages permettent de géocoder des adresses. Le package tidygeocoder (Cambon et al., 2021) permet d’utiliser un grand nombre de services de géocodage en ligne. 4.1.1 tidygeocoder library(tidygeocoder) mes_adresses &lt;- data.frame( address = c(&quot;10 Emma Goldmanweg, 5032MN Tilburg, Netherlands&quot;, &quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;) ) places &lt;- geocode(mes_adresses, address) places # A tibble: 2 × 3 address lat long &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands 51.5 5.04 2 19 rue Michel Bakounine, 29600 Morlaix, France 48.6 -3.82 Site web de tidygeocoder : tidygeocoder 4.2 Transformer les données long/lat en objet sf La fonction st_as_sf() permet de transformer un data.frame contenant des coodonnées géographiques en objet sf. Ici nous utilisons le data.frame places2 créé au point précédent. library(sf) place_sf &lt;- st_as_sf(places, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = 4326) place_sf Simple feature collection with 2 features and 1 field Geometry type: POINT Dimension: XY Bounding box: xmin: -3.816434 ymin: 48.59041 xmax: 5.038699 ymax: 51.53649 Geodetic CRS: WGS 84 # A tibble: 2 × 2 address geometry * &lt;chr&gt; &lt;POINT [°]&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands (5.038699 51.53649) 2 19 rue Michel Bakounine, 29600 Morlaix, France (-3.816435 48.59041) Pour créer un objet sf de type POINT avec uniquement une paire de coordonnées (WGS84, longitude=0.5, latitude = 45.5) : library(sf) mon_point &lt;- st_as_sf(data.frame(x = 0.5, y = 45.5), coords = c(&quot;x&quot;, &quot;y&quot;), crs = 4326) mon_point Simple feature collection with 1 feature and 0 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 0.5 ymin: 45.5 xmax: 0.5 ymax: 45.5 Geodetic CRS: WGS 84 geometry 1 POINT (0.5 45.5) Nous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud, 2021a). library(maptiles) osm &lt;- get_tiles(x = place_sf, zoom = 7) plot_tiles(osm) plot(st_geometry(place_sf), pch = 4, cex = 2, col = &quot;red&quot;, add = TRUE) Focus sur OpenStreetMap 4.3 Digitalisation Le package mapedit (Appelhans et al., 2020) permet de digitaliser des fonds de carte directement dans R. Bien que pouvant se révéler pratique dans certains cas, ce package ne saurait se substituer aux fonctionnalités d’un SIG pour les tâches de digitalisation importantes. Gif taken from mapedit website References Appelhans, T., Russell, K. et Busetto, L. (2020). mapedit: Interactive Editing of Spatial Data in R. https://CRAN.R-project.org/package=mapedit Cambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: Geocoding Made Easy. Zenodo. https://doi.org/10.5281/zenodo.4686074 Giraud, T. (2021a). maptiles: Download and Display Map Tiles. https://github.com/riatelab/maptiles/ "],["les-données-raster-le-package-terra.html", "Chapitre 5 Les données raster: le package terra 5.1 Format des objets SpatRaster 5.2 Import et export de données 5.3 Affichage d’un objet SpatRaster 5.4 Modifications de la zone d’étude 5.5 Algèbre spatial 5.6 Transformation et conversion", " Chapitre 5 Les données raster: le package terra Ce chapitre est largement inspiré de deux présentations; Madelin (2021) et Nowosad (2021); réalisées dans le cadre de l’école thématique SIGR2021. 5.1 Format des objets SpatRaster Le package terra (Hijmans, 2021b) permet de gérer des données vectorielles et raster. Pour manipuler ces données spatiales, terra les stockent dans des objets de type SpatVector et SpatRaster. Dans ce chapitre, nous nous focalisons sur la manipulation de données raster (SpatRaster) à partir de fonctions proposées par ce package. Un objet SpatRaster représente des données matricielles, en une ou plusieurs couches (variables). Cet objet stocke également un certain nombre de paramètres fondamentaux qui le décrivent (nombre de colonnes, de lignes, étendue spatiale, système de référence des coordonnées…). Source : Racine (2016) 5.2 Import et export de données Le package terra permet d’importer et d’exporter des fichiers raster. Il repose sur la bibliothèque GDAL qui permet de lire et de traiter un très grand nombre de format d’images géographiques. library(terra) La fonction rast() permet de créer et/ou d’importer des données raster. Les lignes suivantes importent le fichier raster elevation.tif (Tagged Image File Format) dans un objet de type SpatRaster (par défaut). Elevation_Lot &lt;- rast(&quot;data/elevation.tif&quot;) Elevation_Lot class : SpatRaster dimensions : 2904, 4202, 1 (nrow, ncol, nlyr) resolution : 0.0002972796, 0.0002972796 (x, y) extent : 0.9716575, 2.220826, 44.19333, 45.05663 (xmin, xmax, ymin, ymax) coord. ref. : lon/lat WGS 84 (EPSG:4326) source : elevation.tif name : file1f72aebb76 min value : 53 max value : 778 Modification du nom de la variable stockée (altitude). names(Elevation_Lot) &lt;- &quot;Altitude&quot; La fonction writeRaster() permet d’enregistrer un objet SpatRaster sur votre machine, dans le format de votre choix. writeRaster(x = Elevation_Lot, filename = &quot;data/new_elevation_Lot.tif&quot;) 5.3 Affichage d’un objet SpatRaster La fonction plot() permet d’afficher un objet SpatRaster. plot(Elevation_Lot) Un raster contient toujours des données numériques, mais il peut aussi bien s’agir de données quantitatives que de données qualitatives (catégorielles) codées numériquement (ex: type d’occupation du sol). Précisez le type de données stockées avec l’argument type (type = \"continuous\" par défaut), pour les afficher correctement. Import et affichage d’un raster contenant des données catégorielles : CORINE Land Cover 2018 (type d’occupation du sol) avec une résolution de 100m : # Import des données CORINE Land Cover 2018 # Type d&#39;occupation du sol, résolution de 100m CLC2018_Lot &lt;- rast(&quot;data/CLC2018_Lot.tif&quot;) Ces données ont été récupérées sur le site de Copernicus, le programme européen de surveillance de la Terre qui collecte et met à disposition des données issues de ses propres satellites (Sentinelles) d’observation. Une extraction centrée sur la commune de Cahors a ensuite été réalisée. plot(CLC2018_Lot, type=&quot;classes&quot;) Pour afficher les intitulés réels des types d’occupation du sol, ainsi que les couleurs officielles de la nomenclature CORINE Land Cover (consultables ici), vous pouvez procéder de la manière suivante. intitule_poste &lt;- c( &quot;Tissu urbain continu&quot;, &quot;Tissu urbain discontinu&quot;, &quot;Zones industrielles ou commerciales et installations publiques&quot;, &quot;Réseaux routier et ferroviaire et espaces associés&quot;, &quot;Aéroports&quot;,&quot;Extraction de matériaux&quot;, &quot;Equipements sportifs et de loisirs&quot;, &quot;Terres arables hors périmètres d&#39;irrigation&quot;, &quot;Vignobles&quot;, &quot;Vergers et petits fruits&quot;, &quot;Prairies et autres surfaces toujours en herbe à usage agricole&quot;, &quot;Systèmes culturaux et parcellaires complexes&quot;, &quot;Surfaces essentiellement agricoles (interrompues par espaces nat.)&quot;, &quot;Forêts de feuillus&quot;, &quot;Forêts de conifères&quot;, &quot;Forêts mélangées&quot;, &quot;Pelouses et pâturages naturels&quot;, &quot;Landes et broussailles&quot;, &quot;Végétation sclérophylle&quot;, &quot;Forêt et végétation arbustive en mutation&quot;, &quot;Cours et voies d&#39;eau&quot;, &quot;Plans d&#39;eau&quot; ) couleur_off &lt;- c(&quot;#E6004D&quot;, &quot;#FF0000&quot;, &quot;#CC4DF2&quot;, &quot;#CC0000&quot;, &quot;#E6CCE6&quot;, &quot;#A600CC&quot;, &quot;#FFE6FF&quot;, &quot;#FFFFA8&quot;, &quot;#E68000&quot;, &quot;#F2A64D&quot;, &quot;#E6E64D&quot;, &quot;#FFE64D&quot;, &quot;#E6CC4D&quot;, &quot;#80FF00&quot;, &quot;#00A600&quot;, &quot;#4DFF00&quot;, &quot;#CCF24D&quot;, &quot;#A6FF80&quot;, &quot;#A6E64D&quot;, &quot;#A6F200&quot;, &quot;#00CCF2&quot;, &quot;#80F2E6&quot;) plot(CLC2018_Lot, type = &quot;classes&quot;, levels = intitule_poste, col = couleur_off, plg = list(cex = 0.7), mar = c(3, 1.5, 1, 18.5) ) 5.4 Modifications de la zone d’étude 5.4.1 (Re)projections Pour modifier le système de projection d’un raster, utilisez la fonction project(). Il est alors nécessaire d’indiquer la méthode d’estimation des nouvelles valeurs des cellules. Source : Centre Canadien de Télédétection Quatre méthodes d’estimation sont disponibles : near : plus proche voisin. Méthode rapide et par défaut pour les données qualitatives; bilinear : interpolation bilinéaire. Méthode par défaut pour les données quantitatives; cubic : interpolation cubique; cubicspline : interpolation cubique spline. # Projection en RGF93 / Lambert-93 Elevation_Lot_L93 &lt;- project(x= Elevation_Lot, y = &quot;EPSG:2154&quot;, method = &quot;bilinear&quot;) CLC2018_Lot_L93 &lt;- project(x= CLC2018_Lot, y = &quot;EPSG:2154&quot;, method = &quot;near&quot;) 5.4.2 Crop Le découpage d’un raster en fonction de l’étendue d’un autre objet SpatVector ou SpatRaster est réalisable avec la fonction crop(). Source : Racine (2016) Import de données vectorielles (découpages communaux) avec la fonction vect. Ces données seront stockées dans un objet SpatVector. commune &lt;- vect(&quot;data/lot46.gpkg&quot;, layer=&quot;commune&quot;) Extraction des limites communales de Cahors (code INSEE : 46042). cahors &lt;- subset(commune, commune$INSEE_COM == &quot;46042&quot;) Utilisation de la fonction crop(). Les deux couches de données doivent être dans la même projection. crop_cahors &lt;- crop(Elevation_Lot_L93, cahors) plot(crop_cahors) plot(cahors, add=TRUE) 5.4.3 Mask Pour afficher uniquement les valeurs d’un raster contenu dans un polygone, utilisez la fonction mask(). Source : Racine (2016) Création d’un masque sur le raster crop_cahors en fonction des limites communales (polygone) de cahors. mask_cahors &lt;- mask(crop_cahors, cahors) plot(mask_cahors) 5.4.4 Agrégation &amp; désagrégation Le ré-échantillonnage d’un raster dans une résolution différente se fait en deux étapes. Source : Racine (2016) Afficher la résolution d’un raster avec la fonction res(). # Taille des cellules ? res(Elevation_Lot_L93) [1] 26.99635 26.99635 Créer une grille de même étendue, puis en diminuer la résolution spatiale (plus grosses cellules). Elevation_LowerGrid &lt;- Elevation_Lot_L93 # Tailles des cellules = 1000 mètres res(Elevation_LowerGrid) &lt;- 1000 # res(Elevation_HigherGrid) &lt;- 10 Elevation_LowerGrid class : SpatRaster dimensions : 98, 101, 1 (nrow, ncol, nlyr) resolution : 1000, 1000 (x, y) extent : 537884, 638884, 6344114, 6442114 (xmin, xmax, ymin, ymax) coord. ref. : RGF93 / Lambert-93 (EPSG:2154) La fonction resample() permet de ré-échantillonner les valeurs de départ dans la nouvelle résolution spatiale. Plusieurs méthodes de ré-échantillonnage sont disponibles (cf. partie 5.4.1). Elevation_LowerGrid &lt;- resample(Elevation_Lot_L93, Elevation_LowerGrid, method = &quot;bilinear&quot;) plot(Elevation_LowerGrid, main=&quot;Taille des cellules = 1000m\\nMéthode de ré-échantillonnage bilinéaire&quot;) 5.4.5 Fusion de raster Fusionner plusieurs objets SpatRaster en un seul avec merge() ou mosaic(). Source : https://desktop.arcgis.com/fr/arcmap/10.3/manage-data/raster-and-images/what-is-a-mosaic.htm Après un découpage du raster d’élévation par la limite communale de Cahors (cf partie 5.4.2), nous réalisons la même chose pour la commune limitrophe de Bellefont-La Rauze. # Extraction des limites communales de Bellefont-La Rauze bellefont &lt;- subset(commune, commune$INSEE_COM == &quot;46156&quot;) # Découpage du raster d&#39;élévation en fonction des limites communales crop_bellefont &lt;- crop(Elevation_Lot_L93, bellefont) Les rasters d’élévation crop_cahors et crop_bellefont se chevauchent spatialement : La différence entre les fonctions merge() ou mosaic() concerne les valeurs des cellules qui se superposent. La fonction mosaic() calcule la valeur moyenne tandis que merge() conserve la valeur du premier objet SpatRaster appelé dans la fonction. # Dans cet exemple, merge() et mosaic() donnent le même résultat merge_raster &lt;- merge(crop_cahors, crop_bellefont) mosaic_raster &lt;- mosaic(crop_cahors, crop_bellefont) plot(merge_raster) 5.4.6 segregate Décomposer un raster par valeur (ou modalité) en différentes couches matricielles avec la fonction segregate(). # Création d&#39;une couche matricielle par modalité CLC2018_by_class &lt;- segregate(CLC2018_Lot_L93, keep=TRUE, other=NA) plot(CLC2018_by_class) 5.5 Algèbre spatial L’algèbre spatial se classifie en quatre groupes d’opération (Tomlin, 1990) : Local : opération par cellule, sur une ou plusieurs couches; Focal : opération de voisinage (cellules environnantes); Zonal : pour résumer les valeurs matricielles pour certaines zones, généralement irrégulières; Global : pour résumer les valeurs matricielles d’une ou plusieurs matrices. Source : X. Li (2009) 5.5.1 Opérations locales Source : Mennis (2015) 5.5.1.1 Remplacement de valeur # Remplace les valeurs -9999 par NA Elevation_Lot_L93[Elevation_Lot_L93[[1]]== -9999] &lt;- NA # Remplace les valeurs &lt; 1500 par NA Elevation_Lot_L93[Elevation_Lot_L93 &lt; 1500] &lt;- NA # Remplace les valeurs NA par 0 Elevation_Lot_L93[is.na(Elevation_Lot_L93 )] &lt;- 0 5.5.1.2 Opération sur chaque cellule # Ajout de 1000 à la valeur de chaque cellule Elevation_Lot_1000 &lt;- Elevation_Lot_L93 + 1000 # Suppression de l&#39;altitude médiane à la valeur de chaque cellule Elevation_Lot_median &lt;- Elevation_Lot_L93 - global(Elevation_Lot_L93, median)[[1]] 5.5.1.3 Reclassification La reclassification des valeurs d’un raster peut aussi bien être utilisée pour discrétiser des données quantitatives que pour catégoriser des modalités qualitatives. Cela permet par exemple de répartir les 44 postes de la nomenclature CLC selon les 5 grands types d’occupation du territoire : territoires artificialisés, agricoles, forêts et milieux semi-naturels, zones humides et surfaces en eau. Pour cela, il est d’abord nécessaire de construire la table (matrice) de correspondance. reclassif &lt;- matrix(c(100, 199, 1, 200, 299, 2, 300, 399, 3, 400, 499, 4, 500, 599, 5), ncol = 3, byrow = TRUE) Les valeurs comprises entre 100 et 199 seront remplacées par la valeur 1. Les valeurs comprises entre 200 et 299 seront remplacées par la valeur 2. Les valeurs comprises entre 300 et 399 seront remplacées par la valeur 3. … reclassif [,1] [,2] [,3] [1,] 100 199 1 [2,] 200 299 2 [3,] 300 399 3 [4,] 400 499 4 [5,] 500 599 5 La fonction classify() permet de réaliser la reclassification. CLC2018_5class &lt;- classify(CLC2018_Lot_L93, rcl = reclassif) plot(CLC2018_5class, type =&quot;classes&quot;) Affichage avec les intitulés et couleurs officiels des différentes catégories. plot(CLC2018_5class, type =&quot;classes&quot;, levels=c(&quot;Territoires artificialisés&quot;, &quot;Territoires agricoles&quot;, &quot;Forêts et milieux semi-naturels&quot;, &quot;Surfaces en eau&quot;), col=c(&quot;#E6004D&quot;, &quot;#FFFFA8&quot;, &quot;#80FF00&quot;, &quot;#00CCF2&quot;), mar=c(3, 1.5, 1, 11)) 5.5.1.4 Opération sur plusieurs couches (ex: NDVI) Il est possible de calculer la valeur d’une cellule à partir de ses valeurs stockées dans différentes couches d’un objet SpatRaster. L’exemple le plus courant est sans doute le calcul de l’indice de végétation normalisé (NDVI). Pour chaque cellule, on calcule une valeur à partir de deux couches de données matricielles d’une image satellite multispectrale. # Import d&#39;une image satellite multispectrale Sentinel2a &lt;- rast(&quot;data/Sentinel2A.tif&quot;) Cette image satellite multispectrale (résolution de 10m) datée du 12/10/2021, a été produite par le satellite Sentinel-2 et a été récupéré sur la plateforme Copernicus Open Access Hub. Une extraction des bandes spectrales Rouge et proche infrarouge, centrée sur le département du Lot a ensuite été réalisée. plot(Sentinel2a) Pour alléger le code, on assigne les deux couches matricielles dans des objets SpatRaster différents. # Bande spectrale rouge B04_Red &lt;- Sentinel2a[[1]] # Bande spectrale proche infrarouge B08_NIR &lt;-Sentinel2a[[2]] À partir de ces deux rasters, nous pouvons calculer l’indice de végétation normalisé : \\[{NDVI}=\\frac{\\mathrm{NIR} - \\mathrm{Red}} {\\mathrm{NIR} + \\mathrm{Red}}\\] raster_NDVI &lt;- (B08_NIR - B04_Red ) / (B08_NIR + B04_Red ) plot(raster_NDVI) Plus les valeurs sont importantes (proche de 1), plus la végétation est dense. 5.5.2 Opérations focales Source : Mennis (2015) L’analyse focale considère une cellule plus ses voisins directs de manière contiguë et symétrique (opérations de voisinage). Le plus souvent, la valeur de la cellule de sortie est le résultat d’un bloc de cellules d’entrée 3 x 3 (nombre impair). La première étape consiste à construire une matrice qui détermine le bloc de cellules qui sera pris en compte autour de chaque cellule. # Matrice 5 x 5, où chaque cellule présente la même pondération mon_focal &lt;- matrix(1, nrow = 5, ncol = 5) mon_focal [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 1 1 1 1 [3,] 1 1 1 1 1 [4,] 1 1 1 1 1 [5,] 1 1 1 1 1 La fonction focal() permet de ensuite de réaliser l’analyse souhaitée. Par exemple : le calcul de la moyenne des valeurs de toutes les cellules contiguës, pour chaque cellule du raster. Elevation_LowerGrid_mean &lt;- focal(Elevation_LowerGrid, w = mon_focal, fun = mean) 5.5.2.1 Opération focales pour rasters d’élévation La fonction terrain() permet de réaliser des analyses focales spécifiques au rasters d’élévation. Six opérations sont disponibles : slope = calcul de la pente ou degré d’inclinaison de la surface; aspect = calcul de l’orientation de la pente; roughness = calcul de la variabilité ou l’irrégularité de l’élévation; TPI = calcul de l’indice des positions topographiques; TRI = calcul de l’indice de la variabilité de l’élévation; flowdir = calcul du sens d’écoulement de l’eau. Exemples avec le calcul des pentes (slope). # Calcul de la pente (slope) slope &lt;- terrain(Elevation_Lot_L93, &quot;slope&quot;, neighbors = 8, # 8 (ou 4) cellules autour pris en compte unit = &quot;degrees&quot;) # Unité en sortie # Inclinaison des pentes, en degré plot(slope) 5.5.3 Opérations globales Source : https://gisgeography.com/map-algebra-global-zonal-focal-local/ Les opérations globales permettent de résumer les valeurs matricielles d’une ou plusieurs matrices. # Valeur moyenne global(Elevation_Lot_L93, fun = &quot;mean&quot;) mean Altitude 284.5169 # Écart-type global(Elevation_Lot_L93, fun = &quot;sd&quot;) sd Altitude 135.6232 # Fréquence freq(CLC2018_5class) layer value count 1 1 1 18319 2 1 2 469848 3 1 3 406889 4 1 5 5333 # Tableau de contingence table(CLC2018_5class[]) 1 2 3 5 18319 469848 406889 5333 Représentations statistiques qui résument les informations matricielles. # Histogramme hist(Elevation_Lot_L93) # Densité density(Elevation_Lot_L93) 5.5.4 Opérations zonales Source : Mennis (2015) Les opérations zonales permettent de résumer les valeurs matricielles de certaines zones (groupe de cellules contiguë dans l’espace ou en valeur). 5.5.4.1 Opération zonale sur une extraction Toutes les opérations globales peuvent être réalisées sur une extraction de cellules résultant des fonctions crop(), mask(), segregate()… Exemple : élévation moyenne pour la ville de Cahors (cf partie 5.4.3). # Valeur moyenne du raster &quot;mask&quot; sur Cahors global(mask_cahors, fun = &quot;mean&quot;, na.rm=TRUE) mean Altitude 205.1767 5.5.4.2 Opération zonale à partir d’une couche vectorielle La fonction extract() permet d’extraire et de manipuler les valeurs des cellules qui intersectent des données vectorielles. Exemple à partir de polygones : # Moyenne d&#39;élévation pour chaque polygone (commune) ? elevation_by_com &lt;- extract(Elevation_LowerGrid, commune, fun=mean) head(elevation_by_com, 10) ID Altitude 1 1 203.0747 2 2 383.3535 3 3 325.7307 4 4 417.7236 5 5 124.6304 6 6 202.1067 7 7 214.6572 8 8 237.2690 9 9 345.3603 10 10 216.9668 5.5.4.3 Opération zonale à partir d’un raster Les opérations zonales peuvent être réaliser par zone délimitée par les valeurs catégorielles d’un second raster. Pour cela, les deux rasters doivent avoir exactement le même étendue et la même résolution. # Création d&#39;un second raster # Même résolution et étendue que &quot;Elevation_LowerGrid&quot; second_raster_CLC &lt;- rast(Elevation_LowerGrid) # Ré-échantillonnage du type d&#39;occupation du sol second_raster_CLC &lt;- resample(CLC2018_5class, second_raster_CLC, method = &quot;near&quot;) # Ajout d&#39;un nom de variable pour le second raster names(second_raster_CLC) &lt;- &quot;CLC2018_5class&quot; Calcul de l’élévation moyenne pour les différentes zones du second raster. # Élévation moyenne pour chaque zone du &quot;second_raster&quot; zonal(Elevation_LowerGrid, second_raster_CLC , &quot;mean&quot;, na.rm=TRUE) CLC2018_5class Altitude 1 1 234.4005 2 2 298.2720 3 3 287.8398 4 5 156.1017 5.6 Transformation et conversion 5.6.1 Rasterisation Transformer des polygones en format raster. raster_commune &lt;- rasterize(x = commune, y = Elevation_Lot_L93 , field = 46) plot(raster_commune) Transformer des points en format raster. # Rasterisation des centroïdes des communes raster_com_centroide &lt;- rasterize(x = centroids(commune), y = Elevation_LowerGrid, fun=sum) plot(raster_com_centroide) Transformer des lignes format raster. # Rasterisation des limites communales raster_com_line &lt;- rasterize(x = as.lines(commune), y = Elevation_LowerGrid, fun=sum) plot(raster_com_line) 5.6.2 Vectorisation Transformer un raster en polygones vectoriels. Polygone_Elevation &lt;- as.polygons(Elevation_LowerGrid) plot(Polygone_Elevation, y = 1, border=&quot;white&quot;) Transformer un raster en points vectoriels. Points_Elevation &lt;- as.points(Elevation_LowerGrid) plot(Points_Elevation, y = 1, cex = 0.3) Transformer un raster en lignes vectorielles. Lines_Elevation &lt;- as.lines(Elevation_LowerGrid) plot(Lines_Elevation) 5.6.3 terra, raster, sf, stars… Les packages de références permettant de manipuler les données spatiales reposent tous sur leur propre classe d’objet. Il est parfois nécessaire de convertir ces objets d’une classe à l’autre pour profiter de l’ensemble des fonctionnalités offertes par ces différents packages. Les fonctions de conversion pour les données matricielles : FROM/TO raster terra stars raster rast() st_as_stars() terra raster() st_as_stars() stars raster() as(x, ‘Raster’) + rast() Les fonctions de conversion pour les données vectorielles : FROM/TO sf sp terra sf as(x, ‘Spatial’) vect() sp st_as_sf() vect() terra st_as_sf() as(x, ‘Spatial’) References Hijmans, R. J. (2021b). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra Li, X. (2009). Map algebra and beyond : 1. Map algebra for scalar fields. https://slideplayer.com/slide/5822638/. Madelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html. Mennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html. Nowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html. Racine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster. Tomlin, C. D. (1990). Geographic information systems and cartographic modeling. Prentice Hall. "],["osm.html", "Chapitre 6 Focus sur OpenStreetMap 6.1 Afficher une carte interactive 6.2 Importer les fonds de carte 6.3 Importer des données OSM 6.4 Calculer des itinéraires", " Chapitre 6 Focus sur OpenStreetMap OpenStreetMap (OSM) (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le monde entier. Conditions d’utilisation OpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…) Contributeurs (…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…) A propos d’OpenStreetMap 6.1 Afficher une carte interactive Les deux principaux packages qui permettent d’afficher une carte interactive basées sur OSM sont leaflet (Cheng et al., 2018) et mapview (Appelhans et al., 2018). 6.1.1 leaflet leaflet utilise la libraire javascript Leaflet (Agafonkin, 2015) pour créer des cartes interactives. library(sf) library(leaflet) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) # Sélection de la commune de Cahors cahors &lt;- com[com$INSEE_COM == &quot;46042&quot;, ] # Sélection des restaurants de Cahors restaurant_cahors &lt;- restaurant[restaurant$DEPCOM == &quot;46042&quot;, ] # transformation du système de coordonnées en WGS84 cahors &lt;- st_transform(cahors, 4326) restaurant_cahors &lt;- st_transform(restaurant_cahors, 4326) # Création de la carte interactive m &lt;- leaflet(cahors) %&gt;% addTiles() %&gt;% addPolygons() %&gt;% addMarkers(data = restaurant_cahors) m Site web de leaflet Leaflet for R 6.1.2 mapview mapview s’appuie sur leaflet pour créer des carte interactive, sont utilisation est plus simple et sa documentation est un peu dense. library(mapview) mapview(cahors) + mapview(restaurant_cahors) Site web de mapview mapview 6.2 Importer les fonds de carte Le package maptiles (Giraud, 2021a) permet de télécharger et d’afficher des fonds de cartes raster. La fonction get_tiles() permet de télécharger des fonds de cartes OSM et la fonction plot_tiles() permet de les afficher. Les rendus sont meilleurs si les données en entrée utilisent le même système de coordonnées que les tuiles (EPSG:3857). library(sf) library(maptiles) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) com &lt;- st_transform(com, 3857) osm_tiles &lt;- get_tiles(x = com, zoom = 10, crop = TRUE) plot_tiles(osm_tiles) plot(st_geometry(com), border = &quot;grey20&quot;, lwd = .7, add = TRUE) mtext(side = 1, line = -1, text = get_credit(&quot;OpenStreetMap&quot;), col=&quot;tomato&quot;) 6.3 Importer des données OSM 6.3.1 osmdata Le package osmdata (Padgham et al., 2017a) permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo. Site web du package osmdata library(sf) library(osmdata) library(sf) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) # Sélection de la commune de Cahors cahors &lt;- com[com$INSEE_COM == &quot;46042&quot;, ] # Définition d&#39;une bounding box q &lt;- opq(bbox = st_bbox(st_transform(cahors, 4326))) # Extraction des restaurants req &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;restaurant&quot;) res &lt;- osmdata_sf(req) # Reductcion du resultats # (les points composant les polygones sont supprimés) res &lt;- unique_osmdata(res) Le résultat contient une couche de points et une couche de polygones. La couche de polygones contient des polygones qui représentent des restaurants. Pour obtenir une couche de points cohérente nous pouvons utiliser les centroides des polygones. resto_point &lt;- res$osm_points # extraire les centroides des polygones resto_poly &lt;- res$osm_polygons resto_poly_point &lt;- st_centroid(resto_poly) # identifier les champs en commun chps &lt;- intersect(names(resto_point), names(resto_poly_point)) # rassembler les 2 objets resto &lt;- rbind(resto_point[, chps], resto_poly_point[, chps]) Affichage des résultats library(mapview) mapview(cahors) + mapview(resto) Site web d’osmdata osmdata 6.3.2 osmextract Le package osmextract (Gilardi et Lovelace, 2021) permet d’extraire des données depuis une base de données OSM directement. Ce package permet de travailler sur des volumes de données très importants. Site web d’osmextract osmextract 6.4 Calculer des itinéraires Le package osrm (Giraud, 2021b) sert d’interface entre R et le service de calcul d’itinéraire OSRM (Luxen et Vetter, 2011). Ce package permet de calculer des matrices de temps et de distances, des itinéraires routiers, des isochrones. Le package utilise par défaut le serveur de démo d’OSRM. En cas d’utilisation intensive il est fortement recommandé d’utiliser sa propre instance d’OSRM (avec Docker). 6.4.1 Calcul d’un itinéraire La fonction osrmRoute() permet de calculer des itinéraires. library(sf) library(osrm) library(maptiles) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) com &lt;- st_transform(com, 3857) # Itinéraire entre Cahors et Puybrun cahors &lt;- st_centroid(com[com$INSEE_COM == &quot;46042&quot;, ]) puybrun &lt;- st_centroid(com[com$INSEE_COM == &quot;46229&quot;, ]) route &lt;- osrmRoute(src = cahors, dst = puybrun) osm &lt;- get_tiles(route, crop = TRUE) plot_tiles(osm) plot(st_geometry(route), col = &quot;grey10&quot;, lwd = 6, add = T) plot(st_geometry(route), col = &quot;grey90&quot;, lwd = 1, add = T) 6.4.2 Calcul d’une matrice de temps La fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route. Dans cet exemple nous calculons une matrice de temps entre 2 adresses et les restaurants de Cahors à pied. library(sf) library(tidygeocoder) restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) # Sélection des restaurants de Cahors restaurant_cahors &lt;- restaurant[restaurant$DEPCOM == &quot;46042&quot;, ] # geocodage de 2 adresses à Cahors adresses &lt;- data.frame(ad = c(&quot;3 rue Montaudié, Cahors, France&quot;, &quot;5 rue Albert Camus, Cahors, France&quot;) ) places &lt;- tidygeocoder::geocode(.tbl = adresses,address = ad) places &lt;- as.data.frame(places) row.names(places) &lt;- places$ad # Calcul de la matrice de distance entre les 2 adresses et les restaurants de Cahors mat &lt;- osrmTable(src = places[c(3, 2)], dst = restaurant_cahors, osrm.profile = &quot;foot&quot;) mat$durations[1:2,1:5] 2382 2383 2384 2385 2386 3 rue Montaudié, Cahors, France 18.0 21.3 22.2 22.8 14.6 5 rue Albert Camus, Cahors, France 34.5 66.1 38.6 26.1 35.7 # Quelle adresse possède une meilleurs accessibilité aux restaurants de Cahors? boxplot(t(mat$durations[,]), cex.axis = .7) References Agafonkin, V. (2015). Leaflet javascript libary. Appelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2018). mapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview Cheng, J., Karambelkar, B. et Xie, Y. (2018). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://CRAN.R-project.org/package=leaflet Gilardi, A. et Lovelace, R. (2021). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract Giraud, T. (2021a). maptiles: Download and Display Map Tiles. https://github.com/riatelab/maptiles/ Giraud, T. (2021b). osrm: Interface Between R and the OpenStreetMap-Based Routing Service OSRM. https://CRAN.R-project.org/package=osrm Luxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap data. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062 Padgham, M., Rudis, B., Lovelace, R. et Salmon, M. (2017a). osmdata. The Journal of Open Source Software, 2(14). https://doi.org/10.21105/joss.00305 "],["acquisition-de-données-spatiales.html", "Chapitre 7 Acquisition de données spatiales 7.1 À l’échelle mondiale 7.2 À l’échelle européenne 7.3 À l’échelle national", " Chapitre 7 Acquisition de données spatiales Depuis l’apparition du package sf, qui a très largement contribué à la popularisation de la manipulation de données spatiales avec R, de nombreux packages de mise à disposition de données géographiques (géométries et/ou attributs) ont été développés. Il s’agit le plus souvent de packages d’API qui permettent d’interroger des données mises à disposition sur le Web, directement avec R. Ce chapitre en présente une liste non-exhaustive. 7.1 À l’échelle mondiale rnaturalearth (South, 2017) : permet de récupérer les données cartographiques Natural Earth. gadmr (Guevarra, 2021) : permet de récupérer les données du GADM (découpages administratifs nationaux et infra-nationaux de l’ensemble des pays du monde). rgeoboundaries (Dicko, 2021) : client R pour l’API geoBoundaries, fournissant les frontières administratives politiques des pays. cshapes (Weidmann et al., 2021) : met à disposition les frontières nationales, de 1886 à aujourd’hui. osmextract (Gilardi et Lovelace, 2021) : permet d’importer des données OpenStreetMap. osmdata (Padgham et al., 2017b) : pour télécharger et utiliser les données d’OpenStreetMap. maptiles (Giraud, 2021a) : Ce package télécharge, compose et affiche des tuiles à partir d’un grand nombre de fournisseurs (OpenStreetMap, Stamen, Esri, CARTO ou Thunderforest…). geonames (Rowlingson, 2019) : permet d’interroger la BD geonames, qui fournit notamment des localisations. wbstats (Piburn, 2020) et WDI (Arel-Bundock, 2021) : donnent accès aux données et statistiques de la Banque mondiale. sen2r (Ranghetti et Busetto, 2021) : permet de télécharger et prétraiter automatiquement les données du satellite Sentinel-2. MODIStsp (Busetto et Ranghetti, 2016) : permet de trouver, télécharger et traiter des images MODIS. geodata (Hijmans et al., 2021) : founit un accès à des données sur le climat, l’altitude, le sol, la présence d’espèces et les limites administratives. elevatr (Hollister, 2021) : donne accès à des données d’élévation mises à disposition par Amazon Web Services Terrain Tiles, l’Open Topography Global Datasets API et l’USGS Elevation Point Query Service. rgee (Aybar, 2021) : permet d’utiliser l’API de Google Earth Engine, catalogue de données publiques et infrastructure de calcul pour les images satellites. nasapower (Sparks, 2018) : API client NASA (prévision des ressources énergétiques mondiales, météorologie, énergie solaire de surface et climatologie). geoknife (Read et al., 2015) : permet de traiter (en ligne) des données matricielles volumineuses issuent du Geo Data Portal de l’U.S. Geological Survey. wopr (Leasure et al., 2021) : fournit un accès API à la base de données WorldPop Open Population Repository. rdhs (Watson et al., 2019) : API client et gestions de données de l’enquête démographique et de santé (DHS). 7.2 À l’échelle européenne giscoR (Hernangómez, 2021a) : permet de télécharger des données cartographiques mondiales et européennes de la BD GISCO d’Eurostat (système d’information géographique de la Commission). eurostat (Lahti et al., 2017) : permet de télécharger des données de la BD Eurostat. 7.3 À l’échelle national Brésil geobr (Pereira et Goncalves, 2021) : fournit un accès facile aux séries de données spatiales officielles du Brésil pour différentes années et découpage administratifs. Chili chilemapas (Vargas, 2020) : donne accès aux divisions politiques et administratives du Chili. Espagne mapSpain (Hernangómez, 2021b) : propose les limites administratives de l’Espagne à plusieurs niveaux (Communautés autonomes, Provinces, Municipalités), ainsi que des tuiles. États-Unis tidycensus (Walker et Herman, 2021) : permet de charger des données et géométries du recensement américain en format sf` et `tidyverse tigris (Walker, 2021b) : donne accès aux éléments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l’eau. FedData (Bocinsky, 2019) : automatise le téléchargement de données géospatiales disponibles à partir de plusieurs sources de données fédérées. acs (Glenn, 2019) : permet de télécharger et manipuler les données de l’American Community Survey et les données décennales du recensement des États-Unis. censusapi (Recht, 2020) : wrapper pour les API du Census Bureau des États-Unis. censusGeography (Kaplan, 2016) : Permet de convertir les codes géographiques du recensement des États-Unis en nom de lieu. idbr (Walker, 2021a) : interface avec l’API de la base de données internationale du US Census Bureau. ipumsr (Greg Freedman Ellis et Derek Burk, 2020) : Permet d’importer des données de recensement, d’enquête et géographiques fournies par l’IPUMS. SeerMapper &amp; co (Pearson, 2021) : permettent de cartographier des données par États, comtés, secteurs de recensement ou des registres Seer (découpage du recensement 2000 et 2010). totalcensus (G. Li, 2021) : permet d’extraire les données du recensement décennal et de l’American Community Survey au niveaux des block, block group et tract. UScensus2010 (Almquist, 2021), UScensus2000cdp (Almquist, 2012a) et UScensus2000tract (Almquist, 2012b) : fournissent les géométries du recensement des États-Unis en 2000/2010, ainsi que des données démographiques supplémentaires. Finland mapsFinland (Haukka, 2020) : donne un accès à des cartes et données concernant la Finland. France inseeLocalData (FAURE, 2022) : client R pour l’API Données Locales de l’Insee. insee (Leclerc, 2021) : pour télécharger facilement les données de la base BDM (Banque de Données Macroéconomiques) de l’INSEE. COGugaison (Antunez, s. d.) et CARTElette (Antunez, 2022) : Manipulation, agrégation de données communales françaises et création de couches cartographiques à partir du code officiel géographique (COG) et des couches IGN. Pologne rgugik (Dyba et Nowosad, 2021) : permet l’acquisition automatique de données ouvertes à partir des ressources du Bureau central polonais de la géodésie et de la cartographie (Główny Urząd Geodezji i Kartografii ). Royaume-Uni geographr (Mike Page, 2021) : pour manipuler et cartographier les limites géographiques et administratives du Royaume-Uni. Uruguay geouy (Detomasi, 2021) : permet le chargement d’informations géographiques sur l’Uruguay. … References Almquist, Z. W. (2012a). UScensus2000cdp: US Census 2000 Designated Places Shapefiles and Additional Demographic Data. http://disasternets.calit2.uci.edu/census2000/ Almquist, Z. W. (2012b). UScensus2000tract: US Census 2000 Tract Level Shapefiles and Additional Demographic Data. http://disasternets.calit2.uci.edu/census2000/ Almquist, Z. W. (2021). UScensus2010: US Census 2010 Suite of R Packages. https://github.com/zalmquist/UScensus2010 Antunez, K. (s. d.). package R COGugaison. https://antuki.github.io/COGugaison/ Antunez, K. (2022). CARTElette: Création de couches cartographiques à partir du code officiel géographique (COG) et des couches IGN. http://github.com/antuki/CARTElette/CARTElette Arel-Bundock, V. (2021). WDI: World Development Indicators and Other World Bank Data. https://vincentarelbundock.github.io/WDI/ Aybar, C. (2021). rgee: R Bindings for Calling the Earth Engine API. https://CRAN.R-project.org/package=rgee Bocinsky, R. K. (2019). FedData: Functions to Automate Downloading Geospatial Data Available from Several Federated Data Sources. https://github.com/ropensci/FedData Busetto, L. et Ranghetti, L. (2016). MODIStsp: an R package for preprocessing of MODIS Land Products time series. Computers &amp; Geosciences, 97, 40‑48. https://doi.org/10.1016/j.cageo.2016.08.020 Detomasi, R. (2021). geouy: Geographic Information of Uruguay. https://CRAN.R-project.org/package=geouy Dicko, A. (2021). R client for the geoBoundaries API, providing country political administrative boundaries. https://dickoa.gitlab.io/rgeoboundaries/index.html Dyba, K. et Nowosad, J. (2021). rgugik: Search and Retrieve Spatial Data from the Polish Head Office of Geodesy and Cartography in R. Journal of Open Source Software, 6(59), 2948. https://doi.org/10.21105/joss.02948 FAURE, M.-E. (2022). inseeLocalData: Accès aux données locales de l’Insee via le catalogue des API. Gilardi, A. et Lovelace, R. (2021). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract Giraud, T. (2021a). maptiles: Download and Display Map Tiles. https://github.com/riatelab/maptiles/ Glenn, E. H. (2019). acs: Download, Manipulate, and Present American Community Survey and Decennial Data from the US Census. https://CRAN.R-project.org/package=acs Greg Freedman Ellis et Derek Burk. (2020). ipumsr: Read IPUMS Extract Files. https://CRAN.R-project.org/package=ipumsr Guevarra, E. (2021). gadmr: An R Interface to the GADM Map Repository. https://github.com/SpatialWorks/gadmr Haukka, J. (2020). mapsFinland: Maps of Finland. https://CRAN.R-project.org/package=mapsFinland Hernangómez, D. (2021a). giscoR: Download Map Data from GISCO API - Eurostat. https://CRAN.R-project.org/package=giscoR Hernangómez, D. (2021b). mapSpain: Administrative Boundaries of Spain. https://CRAN.R-project.org/package=mapSpain Hijmans, R. J., Ghosh, A. et Mandel, A. (2021). geodata: Download Geographic Data. https://CRAN.R-project.org/package=geodata Hollister, J. (2021). elevatr: Access Elevation Data from Various APIs. https://github.com/jhollist/elevatr/ Kaplan, J. (2016). censusGeography: Changes United States Census Geographic Code into Name of Location. https://CRAN.R-project.org/package=censusGeography Lahti, L., Huovari, J., Kainu, M. et Biecek, P. (2017). eurostat R package. R Journal. https://journal.r-project.org/archive/2017/RJ-2017-019/index.html Leasure, D. R., Bondarenko, M., Darin, E. et Tatem, A. J. (2021). wopr: An R Package to access the WorldPop Open Population Repository (WOPR). Leclerc, H. (2021). insee: Tools to Easily Download Data from INSEE BDM Database. https://pyr-opendatafr.github.io/R-Insee-Data/ Li, G. (2021). totalcensus: Extract Decennial Census and American Community Survey Data. https://github.com/GL-Li/totalcensus Mike Page, M. T. (British. R. C. S. (2021). R package for mapping UK geographies. https://github.com/britishredcrosssociety/geographr Padgham, M., Rudis, B., Lovelace, R. et Salmon, M. (2017b). osmdata. The Journal of Open Source Software, 2(14). https://doi.org/10.21105/joss.00305 Pearson, J. (2021). SeerMapper: A Quick Way to Map U.S. Rates and Data of U.S. States, Counties, Census Tracts, or Seer Registries using 2000 and 2010 U.S. Census Boundaries. https://CRAN.R-project.org/package=SeerMapper Pereira, R. H. M. et Goncalves, C. N. (2021). geobr: Download Official Spatial Data Sets of Brazil. https://github.com/ipeaGIT/geobr Piburn, J. (2020). wbstats: Programmatic Access to the World Bank API. Oak Ridge National Laboratory. https://doi.org/10.11578/dc.20171025.1827 Ranghetti, L. et Busetto, L. (2021). sen2r: Find, Download and Process Sentinel-2 Data. https://sen2r.ranghetti.info Read, J. S., Walker, J. I., Appling, A., Blodgett, D. L., Read, E. K. et Winslow, L. A. (2015). geoknife: Reproducible web-processing of large gridded datasets. Ecography. https://doi.org/10.1111/ecog.01880 Recht, H. (2020). censusapi: Retrieve Data from the Census APIs. https://github.com/hrecht/censusapi Rowlingson, B. (2019). geonames: Interface to the \"Geonames\" Spatial Query Web Service. https://CRAN.R-project.org/package=geonames South, A. (2017). rnaturalearth: World Map Data from Natural Earth. https://github.com/ropenscilabs/rnaturalearth Sparks, A. H. (2018). nasapower: A NASA POWER Global Meteorology, Surface Solar Energy and Climatology Data Client for R. The Journal of Open Source Software, 3(30), 1035. https://doi.org/10.21105/joss.01035 Vargas, M. (2020). chilemapas: Mapas de las Divisiones Politicas y Administrativas de Chile (Maps of the Political and Administrative Divisions of Chile). https://pachamaltese.github.io/chilemapas/ Walker, K. (2021a). idbr: R Interface to the US Census Bureau International Data Base API. https://CRAN.R-project.org/package=idbr Walker, K. (2021b). tigris: Load Census TIGER/Line Shapefiles. https://github.com/walkerke/tigris Walker, K. et Herman, M. (2021). tidycensus: Load US Census Boundary and Attribute Data as tidyverse and sf-Ready Data Frames. https://walker-data.com/tidycensus/ Watson, O. J., FitzJohn, R. et Eaton, J. W. (2019). rdhs: an R package to interact with The Demographic and Health Surveys (DHS) Program datasets. Wellcome Open Research, 4, 103. https://doi.org/10.12688/wellcomeopenres.15311.1 Weidmann, N. B., Schvitz, G. et Girardin, L. (2021). cshapes: The CShapes 2.0 Dataset and Utilities. https://CRAN.R-project.org/package=cshapes "],["sessioninfo.html", "Chapitre 8 sessionInfo()", " Chapitre 8 sessionInfo() R version 4.2.2 (2022-10-31) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Debian GNU/Linux 11 (bullseye) Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C LC_TIME=fr_FR.UTF-8 [4] LC_COLLATE=fr_FR.UTF-8 LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] osrm_4.0.1 osmdata_0.1.10 mapview_2.11.0 leaflet_2.1.1 [5] terra_1.6-47 maptiles_0.4.0 tidygeocoder_1.0.5 mapsf_0.6.1 [9] sf_1.0-9 knitr_1.41 loaded via a namespace (and not attached): [1] httr_1.4.4 sass_0.4.4 jsonlite_1.8.4 [4] bslib_0.4.2 assertthat_0.2.1 sp_1.5-1 [7] highr_0.10 stats4_4.2.2 yaml_2.3.6 [10] pillar_1.8.1 lattice_0.20-45 glue_1.6.2 [13] uuid_1.1-0 digest_0.6.31 RColorBrewer_1.1-3 [16] colorspace_2.0-3 leaflet.providers_1.9.0 htmltools_0.5.4 [19] slippymath_0.3.1 pkgconfig_2.0.3 raster_3.6-13 [22] s2_1.1.1 bookdown_0.31 purrr_1.0.0 [25] scales_1.2.1 webshot_0.5.4 brew_1.0-8 [28] svglite_2.1.0 satellite_1.0.4 timechange_0.1.1 [31] tibble_3.1.8 proxy_0.4-27 generics_0.1.3 [34] ellipsis_0.3.2 googlePolylines_0.8.2 cachem_1.0.6 [37] cli_3.6.0 magrittr_2.0.3 evaluate_0.19 [40] fansi_1.0.3 xml2_1.3.3 class_7.3-20 [43] httr2_0.2.2 tools_4.2.2 mapiso_0.2.0 [46] lifecycle_1.0.3 stringr_1.5.0 munsell_0.5.0 [49] isoband_0.2.7 compiler_4.2.2 jquerylib_0.1.4 [52] e1071_1.7-12 systemfonts_1.0.4 rlang_1.0.6 [55] classInt_0.4-8 units_0.8-1 grid_4.2.2 [58] leafpop_0.1.0 rstudioapi_0.14 rappdirs_0.3.3 [61] htmlwidgets_1.6.1 crosstalk_1.2.0 leafem_0.2.0 [64] base64enc_0.1-3 rmarkdown_2.19 wk_0.7.1 [67] codetools_0.2-18 DBI_1.1.3 curl_4.3.3 [70] RcppSimdJson_0.1.8 R6_2.5.1 lubridate_1.9.0 [73] dplyr_1.0.10 fastmap_1.1.0 utf8_1.2.2 [76] KernSmooth_2.23-20 stringi_1.7.8 Rcpp_1.0.9 [79] vctrs_0.5.1 png_0.1-8 tidyselect_1.2.0 [82] xfun_0.36 "],["references.html", "References", " References Agafonkin, V. (2015). Leaflet javascript libary. Almquist, Z. W. (2012a). UScensus2000cdp: US Census 2000 Designated Places Shapefiles and Additional Demographic Data. http://disasternets.calit2.uci.edu/census2000/ Almquist, Z. W. (2012b). UScensus2000tract: US Census 2000 Tract Level Shapefiles and Additional Demographic Data. http://disasternets.calit2.uci.edu/census2000/ Almquist, Z. W. (2021). UScensus2010: US Census 2010 Suite of R Packages. https://github.com/zalmquist/UScensus2010 Antunez, K. (s. d.). package R COGugaison. https://antuki.github.io/COGugaison/ Antunez, K. (2022). CARTElette: Création de couches cartographiques à partir du code officiel géographique (COG) et des couches IGN. http://github.com/antuki/CARTElette/CARTElette Appelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2018). mapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview Appelhans, T., Russell, K. et Busetto, L. (2020). mapedit: Interactive Editing of Spatial Data in R. https://CRAN.R-project.org/package=mapedit Arel-Bundock, V. (2021). WDI: World Development Indicators and Other World Bank Data. https://vincentarelbundock.github.io/WDI/ Aybar, C. (2021). rgee: R Bindings for Calling the Earth Engine API. https://CRAN.R-project.org/package=rgee Bivand, R. S. (2020). Progress in the R ecosystem for representing and handling spatial data. Journal of Geographical Systems, 1‑32. Bivand, R., Keitt, T. et Rowlingson, B. (2018). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal Bivand, R. et Rundel, C. (2018). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos Bocinsky, R. K. (2019). FedData: Functions to Automate Downloading Geospatial Data Available from Several Federated Data Sources. https://github.com/ropensci/FedData Busetto, L. et Ranghetti, L. (2016). MODIStsp: an R package for preprocessing of MODIS Land Products time series. Computers &amp; Geosciences, 97, 40‑48. https://doi.org/10.1016/j.cageo.2016.08.020 Cambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: Geocoding Made Easy. Zenodo. https://doi.org/10.5281/zenodo.4686074 Cheng, J., Karambelkar, B. et Xie, Y. (2018). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://CRAN.R-project.org/package=leaflet Detomasi, R. (2021). geouy: Geographic Information of Uruguay. https://CRAN.R-project.org/package=geouy Dicko, A. (2021). R client for the geoBoundaries API, providing country political administrative boundaries. https://dickoa.gitlab.io/rgeoboundaries/index.html Dyba, K. et Nowosad, J. (2021). rgugik: Search and Retrieve Spatial Data from the Polish Head Office of Geodesy and Cartography in R. Journal of Open Source Software, 6(59), 2948. https://doi.org/10.21105/joss.02948 FAURE, M.-E. (2022). inseeLocalData: Accès aux données locales de l’Insee via le catalogue des API. GDAL/OGR contributors. (s. d.). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://gdal.org Gilardi, A. et Lovelace, R. (2021). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract Giraud, T. (2021a). maptiles: Download and Display Map Tiles. https://github.com/riatelab/maptiles/ Giraud, T. (2021b). osrm: Interface Between R and the OpenStreetMap-Based Routing Service OSRM. https://CRAN.R-project.org/package=osrm Glenn, E. H. (2019). acs: Download, Manipulate, and Present American Community Survey and Decennial Data from the US Census. https://CRAN.R-project.org/package=acs Greg Freedman Ellis et Derek Burk. (2020). ipumsr: Read IPUMS Extract Files. https://CRAN.R-project.org/package=ipumsr Guevarra, E. (2021). gadmr: An R Interface to the GADM Map Repository. https://github.com/SpatialWorks/gadmr Haukka, J. (2020). mapsFinland: Maps of Finland. https://CRAN.R-project.org/package=mapsFinland Hernangómez, D. (2021a). giscoR: Download Map Data from GISCO API - Eurostat. https://CRAN.R-project.org/package=giscoR Hernangómez, D. (2021b). mapSpain: Administrative Boundaries of Spain. https://CRAN.R-project.org/package=mapSpain Hijmans, R. J. (2021a). raster: Geographic Data Analysis and Modeling. https://CRAN.R-project.org/package=raster Hijmans, R. J. (2021b). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra Hijmans, R. J., Ghosh, A. et Mandel, A. (2021). geodata: Download Geographic Data. https://CRAN.R-project.org/package=geodata Hollister, J. (2021). elevatr: Access Elevation Data from Various APIs. https://github.com/jhollist/elevatr/ Kaplan, J. (2016). censusGeography: Changes United States Census Geographic Code into Name of Location. https://CRAN.R-project.org/package=censusGeography Lahti, L., Huovari, J., Kainu, M. et Biecek, P. (2017). eurostat R package. R Journal. https://journal.r-project.org/archive/2017/RJ-2017-019/index.html Leasure, D. R., Bondarenko, M., Darin, E. et Tatem, A. J. (2021). wopr: An R Package to access the WorldPop Open Population Repository (WOPR). Leclerc, H. (2021). insee: Tools to Easily Download Data from INSEE BDM Database. https://pyr-opendatafr.github.io/R-Insee-Data/ Li, G. (2021). totalcensus: Extract Decennial Census and American Community Survey Data. https://github.com/GL-Li/totalcensus Li, X. (2009). Map algebra and beyond : 1. Map algebra for scalar fields. https://slideplayer.com/slide/5822638/. Lovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation with R. CRC Press. https://geocompr.robinlovelace.net/ Luxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap data. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062 Madelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html. Mennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html. Mike Page, M. T. (British. R. C. S. (2021). R package for mapping UK geographies. https://github.com/britishredcrosssociety/geographr Nowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html. Padgham, M., Rudis, B., Lovelace, R. et Salmon, M. (2017a). osmdata. The Journal of Open Source Software, 2(14). https://doi.org/10.21105/joss.00305 Padgham, M., Rudis, B., Lovelace, R. et Salmon, M. (2017b). osmdata. The Journal of Open Source Software, 2(14). https://doi.org/10.21105/joss.00305 Pearson, J. (2021). SeerMapper: A Quick Way to Map U.S. Rates and Data of U.S. States, Counties, Census Tracts, or Seer Registries using 2000 and 2010 U.S. Census Boundaries. https://CRAN.R-project.org/package=SeerMapper Pebesma, E. (2018a). sf: Simple Features for R. https://CRAN.R-project.org/package=sf Pebesma, E. (2018b). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal. https://journal.r-project.org/archive/2018/RJ-2018-009/index.html Pebesma, E. (2021). stars: Spatiotemporal Arrays, Raster and Vector Data Cubes. https://CRAN.R-project.org/package=stars Pebesma, E. et Bivand, R. (2018). sp: Classes and Methods for Spatial Data. https://CRAN.R-project.org/package=sp Pereira, R. H. M. et Goncalves, C. N. (2021). geobr: Download Official Spatial Data Sets of Brazil. https://github.com/ipeaGIT/geobr Piburn, J. (2020). wbstats: Programmatic Access to the World Bank API. Oak Ridge National Laboratory. https://doi.org/10.11578/dc.20171025.1827 PROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/ Racine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster. Ranghetti, L. et Busetto, L. (2021). sen2r: Find, Download and Process Sentinel-2 Data. https://sen2r.ranghetti.info Read, J. S., Walker, J. I., Appling, A., Blodgett, D. L., Read, E. K. et Winslow, L. A. (2015). geoknife: Reproducible web-processing of large gridded datasets. Ecography. https://doi.org/10.1111/ecog.01880 Recht, H. (2020). censusapi: Retrieve Data from the Census APIs. https://github.com/hrecht/censusapi Rowlingson, B. (2019). geonames: Interface to the \"Geonames\" Spatial Query Web Service. https://CRAN.R-project.org/package=geonames South, A. (2017). rnaturalearth: World Map Data from Natural Earth. https://github.com/ropenscilabs/rnaturalearth Sparks, A. H. (2018). nasapower: A NASA POWER Global Meteorology, Surface Solar Energy and Climatology Data Client for R. The Journal of Open Source Software, 3(30), 1035. https://doi.org/10.21105/joss.01035 Tomlin, C. D. (1990). Geographic information systems and cartographic modeling. Prentice Hall. Vargas, M. (2020). chilemapas: Mapas de las Divisiones Politicas y Administrativas de Chile (Maps of the Political and Administrative Divisions of Chile). https://pachamaltese.github.io/chilemapas/ Walker, K. (2021a). idbr: R Interface to the US Census Bureau International Data Base API. https://CRAN.R-project.org/package=idbr Walker, K. (2021b). tigris: Load Census TIGER/Line Shapefiles. https://github.com/walkerke/tigris Walker, K. et Herman, M. (2021). tidycensus: Load US Census Boundary and Attribute Data as tidyverse and sf-Ready Data Frames. https://walker-data.com/tidycensus/ Watson, O. J., FitzJohn, R. et Eaton, J. W. (2019). rdhs: an R package to interact with The Demographic and Health Surveys (DHS) Program datasets. Wellcome Open Research, 4, 103. https://doi.org/10.12688/wellcomeopenres.15311.1 Weidmann, N. B., Schvitz, G. et Girardin, L. (2021). cshapes: The CShapes 2.0 Dataset and Utilities. https://CRAN.R-project.org/package=cshapes "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
