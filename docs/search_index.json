[["index.html", "Géomatique avec R Chapitre 1 Préambule", " Géomatique avec R Timothée Giraud1 &amp; Hugues Pecout2 14 décembre 2021 Chapitre 1 Préambule Ce manuel est destiné tant aux utilisateurs de R souhaitant mettre en place traitements de l’information géographique qu’aux utilisateurs souhaitant utiliser R pour réaliser les taches qu’ils réalisent habituellement avec un SIG. Les principales étapes du traitement de l’information géographiques y sont abordées. L’accent est porté sur le traitement des données vectorielles mais une partie est tout de même dédiée aux données raster. Comment utiliser le manuel Le projet RStudio contenant l’ensemble des données utilisées dans le manuel est disponible ici. Une fois le dossier décompressé il est possible de tester l’ensemble des manipulations proposées dans le projet RStudio. Contribution et feedback Vous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le dépôt GitHub de ce document. La version en ligne de ce document est sous licence Creative Commons Attribution-NonCommercial-ShareAlike 4.0. UMS RIATE, CNRS, Université de Paris, F-75013 Paris, France↩︎ FR CIST, CNRS, F-75013 Paris, France↩︎ "],["introductionx.html", "Chapitre 2 Introduction 2.1 Le spatial dans R : Historique et évolutions 2.2 Le package sf 2.3 Le package terra", " Chapitre 2 Introduction 2.1 Le spatial dans R : Historique et évolutions Historiquement, 4 packages permettent d’importer, de manipuler et de transformer les données spatiales : Le package rgdal (R. Bivand, Keitt, and Rowlingson 2018) qui est une interface entre R et les librairies GDAL (GDAL/OGR contributors, n.d.) et PROJ (PROJ contributors 2021) permet d’importer et d’exporter les données spatiales (les shapefiles par exemple) et aussi de gérer les projections cartographiques Le package sp (Pebesma and Bivand 2018) fournit des classes et méthodes pour les données spatiales vectorielles dans R. Il permet afficher des fond de cartes, d’inspecter une table attributaire etc. Le package rgeos (R. Bivand and Rundel 2018) donne accès à la librairie d’opérations spatiales GEOS et rend donc disponible les opérations SIG classiques : calcul de surfaces ou de périmètres, calcul de distances, agrégations spatiales, zones tampons, intersections etc. Le package raster (Hijmans 2021a) est dédié à l’import, la mabipulation et la modélisation des données raster. Aujourd’hui, les principaux développements concernants les données vectorielles se sont détachés des 3 anciens (sp, rgdal, rgeos) pour se reposer principalement sur le package sf ((Pebesma 2018a), (Pebesma 2018b)). Dans ce manuel nous nous appuierons exclusivement sur ce package pour manipuler les données vectorielles. Les packages stars (Pebesma 2021) et terra(Hijmans 2021b) sont venus quand à eux remplacer le package raster pour le traitement des données raster. Nous avons choisi d’utiliser ici le package terra pour sa proximité avec le package raster. En savoir plus sur l’écosysteme spatial de R : Progress in the R ecosystem for representing and handling spatial data (R. S. Bivand 2020) CRAN Task View : Analysis of Spatial Data Liste de discussion : R Special Interest Group on using Geographical data and Mapping Manuel en anglais : Geocomputation with R (Lovelace, Nowosad, and Muenchow 2019) 2.2 Le package sf Le package sf a été publié fin 2016 par Edzer Pebesma (également auteur de sp). Son objectif est de combiner les fonctionnalités de sp, rgeos et rgdal dans un package unique plus ergonomique. Ce package propose des objets plus simples (suivant le standard simple feature) dont la manipulation est plus aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe et les opérateurs du tidyverse. sf utilise directement les librairies GDAL, GEOS et PROJ. From r-spatial.org Site web du package sf : Simple Features for R 2.3 Le package terra Le package terra a été publié début 2020 par Robert J. Hijmans (également auteur de raster). Son objectif est de proposer des méthodes de traitement et d’analyse de données rasrer. Ce package est très similaire au package raster; mais il propose plus de fonctionnalités, il est plus facile à utiliser et il est plus rapide. Site web du package terra : Spatial Data Science with R and “terra” References "],["les-données-vectorielles.html", "Chapitre 3 Les données vectorielles 3.1 Format des objets spatiaux sf 3.2 Import et export de données 3.3 Affichage 3.4 Les systèmes de coordonnées 3.5 Sélection par attributs 3.6 Sélection spatiale 3.7 Opérations sur les géométries 3.8 Mesures", " Chapitre 3 Les données vectorielles 3.1 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry). Ce format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet. Vignette décrivant le format simple feature : Simple Features for R 3.2 Import et export de données Les fonctions st_read() et st_write() permettent d’importer et d’exporter de nombreux types de fichiers. Les lignes suivantes importent la couche des communes du département du Lot situé dans le fichier geopackage lot46.gpkg. library(sf) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;) Reading layer `commune&#39; from data source `/home/tim/Documents/prj/geomatique_avec_r/data/lot46.gpkg&#39; using driver `GPKG&#39; Simple feature collection with 313 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668 Projected CRS: RGF93_Lambert_93 Les lignes suivantes exportent l’objet com dans un dossier data aux formats geopackage et shapefile. st_write(obj = com, dsn = &quot;data/com.gpkg&quot;, layer = &quot;commune&quot;, delete_layer = TRUE) Writing layer `commune&#39; to data source `data/com.gpkg&#39; using driver `GPKG&#39; Writing 313 features with 14 fields and geometry type Multi Polygon. st_write(obj = com, &quot;data/com.shp&quot;, layer_options = &quot;ENCODING=UTF-8&quot;, delete_layer = TRUE) Writing layer `com&#39; to data source `data/com.shp&#39; using driver `ESRI Shapefile&#39; options: ENCODING=UTF-8 Writing 313 features with 14 fields and geometry type Multi Polygon. 3.3 Affichage Aperçu des variables via les fonctions head() et plot(). head(com) Simple feature collection with 6 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 590456.5 ymin: 6412754 xmax: 630241.5 ymax: 6433202 Projected CRS: RGF93_Lambert_93 ID NOM_COM NOM_COM_M INSEE_COM 1 COMMUNE_0000000009755534 Sousceyrac-en-Quercy SOUSCEYRAC-EN-QUERCY 46311 2 COMMUNE_0000000009755131 Strenquels STRENQUELS 46312 3 COMMUNE_0000000009755550 Floirac FLOIRAC 46106 4 COMMUNE_0000000009755546 Padirac PADIRAC 46213 5 COMMUNE_0000000009755771 Thégra THEGRA 46317 6 COMMUNE_0000000009755545 Tauriac TAURIAC 46313 STATUT X_COM Y_COM SUPERFICIE POPULATION INSEE_ARR NOM_DEP INSEE_DEP 1 Commune simple 623751 6423411 14030 1341 2 LOT 46 2 Commune simple 592601 6431381 901 272 3 LOT 46 3 Commune simple 595163 6423919 1902 250 3 LOT 46 4 Commune simple 601596 6417720 886 155 3 LOT 46 5 Commune simple 601233 6414592 1282 477 3 LOT 46 6 Commune simple 602054 6424495 823 430 2 LOT 46 NOM_REG INSEE_REG geom 1 OCCITANIE 76 MULTIPOLYGON (((624106.2 64... 2 OCCITANIE 76 MULTIPOLYGON (((592233.5 64... 3 OCCITANIE 76 MULTIPOLYGON (((597765.4 64... 4 OCCITANIE 76 MULTIPOLYGON (((601119.9 64... 5 OCCITANIE 76 MULTIPOLYGON (((599080.5 64... 6 OCCITANIE 76 MULTIPOLYGON (((603268.3 64... plot(com) Affichage de la géométrie uniquement. plot(st_geometry(com)) 3.4 Les systèmes de coordonnées 3.4.1 Consulter le système de coordonnées d’un objet La fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf. st_crs(com) Coordinate Reference System: User input: RGF93_Lambert_93 wkt: PROJCRS[&quot;RGF93_Lambert_93&quot;, BASEGEOGCRS[&quot;RGF93&quot;, DATUM[&quot;Reseau Geodesique Francais 1993&quot;, ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, LENGTHUNIT[&quot;metre&quot;,1]]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433]], ID[&quot;EPSG&quot;,4171]], CONVERSION[&quot;unnamed&quot;, METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, ID[&quot;EPSG&quot;,9802]], PARAMETER[&quot;Latitude of false origin&quot;,46.5, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8821]], PARAMETER[&quot;Longitude of false origin&quot;,3, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8822]], PARAMETER[&quot;Latitude of 1st standard parallel&quot;,44, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8823]], PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,49, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8824]], PARAMETER[&quot;Easting at false origin&quot;,700000, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8826]], PARAMETER[&quot;Northing at false origin&quot;,6600000, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8827]]], CS[Cartesian,2], AXIS[&quot;easting&quot;,east, ORDER[1], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]], AXIS[&quot;northing&quot;,north, ORDER[2], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]]] 3.4.2 Modifier le système de coordonnées d’un objet La fonction st_transform() permet de change le système de coordonnées d’un objet sf, de le reprojeter. plot(st_geometry(com)) title(&quot;RGF93 / Lambert-93&quot;) com_reproj &lt;- st_transform(com, &quot;epsg:3035&quot;) plot(st_geometry(com_reproj)) title(&quot;ETRS89-extended / LAEA Europe&quot;) Le site Spatial Reference met à disposition les références de très nombreux systèmes de coordonnées. 3.5 Sélection par attributs Les objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame. # selection de ligne com[1:2, ] Simple feature collection with 2 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 590456.5 ymin: 6413499 xmax: 630241.5 ymax: 6433202 Projected CRS: RGF93_Lambert_93 ID NOM_COM NOM_COM_M INSEE_COM 1 COMMUNE_0000000009755534 Sousceyrac-en-Quercy SOUSCEYRAC-EN-QUERCY 46311 2 COMMUNE_0000000009755131 Strenquels STRENQUELS 46312 STATUT X_COM Y_COM SUPERFICIE POPULATION INSEE_ARR NOM_DEP INSEE_DEP 1 Commune simple 623751 6423411 14030 1341 2 LOT 46 2 Commune simple 592601 6431381 901 272 3 LOT 46 NOM_REG INSEE_REG geom 1 OCCITANIE 76 MULTIPOLYGON (((624106.2 64... 2 OCCITANIE 76 MULTIPOLYGON (((592233.5 64... com[com$NOM_COM == &quot;Gramat&quot;, ] Simple feature collection with 1 feature and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784 Projected CRS: RGF93_Lambert_93 ID NOM_COM NOM_COM_M INSEE_COM STATUT X_COM Y_COM 212 COMMUNE_0000000009756022 Gramat GRAMAT 46128 Commune simple 598325 6408057 SUPERFICIE POPULATION INSEE_ARR NOM_DEP INSEE_DEP NOM_REG INSEE_REG 212 5707 3468 3 LOT 46 OCCITANIE 76 geom 212 MULTIPOLYGON (((594713.1 64... # selection de colonnes com[com$NOM_COM == &quot;Gramat&quot;, 1:4] Simple feature collection with 1 feature and 4 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784 Projected CRS: RGF93_Lambert_93 ID NOM_COM NOM_COM_M INSEE_COM geom 212 COMMUNE_0000000009756022 Gramat GRAMAT 46128 MULTIPOLYGON (((594713.1 64... 3.6 Sélection spatiale 3.6.1 Intersections Sélection des routes intesectant la commune de Gramat. route &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;route&quot;, quiet = TRUE) gramat &lt;- com[com$NOM_COM == &quot;Gramat&quot;, ] inter &lt;- st_intersects(x = route, y = gramat, sparse = FALSE) head(inter) [,1] [1,] FALSE [2,] FALSE [3,] FALSE [4,] FALSE [5,] FALSE [6,] FALSE route$intersect_gramat &lt;- inter plot(st_geometry(gramat), col = &quot;lightblue&quot;) plot(st_geometry(route), add = TRUE) plot(st_geometry(route[route$intersect_gramat, ]), col = &quot;tomato&quot;, lwd = 2, add = TRUE) Il est possible de faire autrement : route &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;route&quot;, quiet = TRUE) gramat &lt;- com[com$NOM_COM == &quot;Gramat&quot;, ] rinter &lt;- route[gramat, op = st_intersects] plot(st_geometry(gramat), col = &quot;lightblue&quot;) plot(st_geometry(route), add = TRUE) plot(st_geometry(rinter), col = &quot;tomato&quot;, lwd = 2, add = TRUE) 3.6.2 Contains / Within Sélection des routes contenues dans la commune de Gramat route$within_gramat &lt;- st_within(route, gramat, sparse = FALSE) plot(st_geometry(gramat), col = &quot;lightblue&quot;) plot(st_geometry(route), add = TRUE) plot(st_geometry(route[route$within_gramat, ]), col = &quot;tomato&quot;, lwd = 2, add = TRUE) 3.7 Opérations sur les géométries 3.7.1 Extraire des centroides com_c &lt;- st_centroid(com) plot(st_geometry(com)) plot(st_geometry(com_c), add = TRUE, cex = 1.2, col = &quot;red&quot;, pch = 20) 3.7.2 Agréger des polygones dep_46 &lt;- st_union(com) plot(st_geometry(com), col = &quot;lightblue&quot;) plot(st_geometry(dep_46), add = TRUE, lwd = 2, border = &quot;red&quot;) 3.7.3 Agréger des polygones en fonction d’une variable com_u &lt;- aggregate(x = com[,c(&quot;POPULATION&quot;, &quot;SUPERFICIE&quot;)], by = list(STATUS = com$INSEE_ARR), FUN = &quot;sum&quot;) plot(com_u) 3.7.4 Construire une zone tampon gramat_b &lt;- st_buffer(x = gramat, dist = 5000) plot(st_geometry(gramat_b), col = &quot;lightblue&quot;, lwd=2, border = &quot;red&quot;) plot(st_geometry(gramat), add = TRUE, lwd = 2) 3.7.5 Réaliser une intersection zone &lt;- st_geometry(gramat) |&gt; st_centroid() |&gt; st_buffer(10000) plot(st_geometry(com)) plot(zone, border = &quot;red&quot;, lwd = 2, add = TRUE) com_z &lt;- st_intersection(x = com, y = zone) plot(st_geometry(com)) plot(st_geometry(com_z), col=&quot;red&quot;, border=&quot;green&quot;, add=T) plot(st_geometry(com_z)) 3.7.6 Créer une grille régulière grid &lt;- st_make_grid(x = com, cellsize = 2500) grid &lt;- st_sf(ID = 1:length(grid), geom = grid) plot(st_geometry(grid), col = &quot;grey&quot;, border = &quot;white&quot;) plot(st_geometry(com), border = &quot;grey50&quot;, add = TRUE) 3.7.7 Compter des points dans un polygone grid &lt;- grid[st_intersects(grid, dep_46, sparse = FALSE), ] restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) plot(st_geometry(grid), col = &quot;grey&quot;, border = &quot;white&quot;) plot(st_geometry(restaurant), pch = 20, col = &quot;red&quot;, add = TRUE, cex = .2) inter &lt;- st_intersects(grid, restaurant) grid$nb_restaurant &lt;- sapply(X = inter, FUN = length) plot(grid[&quot;nb_restaurant&quot;]) 3.8 Mesures 3.8.1 Créer une matrice de distances Si le système de projection du jeu de données est renseigné les distances sont exprimées dans l’unité de mesure de la projection (en mètres le plus souvent). mat &lt;- st_distance(x = com_c, y = com_c) mat[1:5,1:5] Units: [m] [,1] [,2] [,3] [,4] [,5] [1,] 0.00 32129.898 28427.284 22653.980 23874.797 [2,] 32129.90 0.000 8138.989 16688.438 19036.897 [3,] 28427.28 8138.989 0.000 9029.510 11058.602 [4,] 22653.98 16688.438 9029.510 0.000 2935.613 [5,] 23874.80 19036.897 11058.602 2935.613 0.000 3.8.2 Mesurer les longueurs et les surfaces Mesurer la densité du réseau routier Intersecter les routes par les communes Nous découpons les routes par les communes. Chaque segment de route récupère l’identifiant de la commune dans laquelle il se trouve. route_com &lt;- st_intersection(route, com[,&quot;INSEE_COM&quot;]) head(route_com, 1) Simple feature collection with 1 feature and 20 fields Geometry type: LINESTRING Dimension: XY Bounding box: xmin: 620262.6 ymin: 6427445 xmax: 620325.5 ymax: 6427855 Projected CRS: RGF93_Lambert_93 ID VOCATION NB_CHAUSSE NB_VOIES ETAT ACCES POS_SOL 30 BDCTRORO0000000021253313 Liaison locale 1 chaussée 1 voie Revêtu Libre Au sol RES_VERT SENS NB_VOIES_M NB_VOIES_D TOPONYME USAGE 30 Non Double sens Sans objet Sans objet &lt;NA&gt; Logique et cartographique DATE NUM_ROUTE CLASS_ADM GEST_ROUTE intersect_gramat within_gramat 30 2021-05-07 D40 Départementale 46 FALSE FALSE INSEE_COM geom 30 46311 LINESTRING (620262.6 642785... Calculer la longueur des segments de route Nous rajoutons une colonne longueur qui contient la longueur de chacun des segments. route_com$longueur &lt;- st_length(route_com) Calculer la longueur totale par commune Nous aggrégeons les segments de routes par commune pour obtenir des longueurs totales par commune. longueur_total &lt;- aggregate(x = list(longueur = route_com$longueur), by = list(INSEE_COM = route_com$INSEE_COM), FUN = sum) Joindre les longueurs à la table des communes com_dens &lt;- merge(x = com[,c(&#39;INSEE_COM&#39;, &quot;POPULATION&quot;)], y = longueur_total, by = &quot;INSEE_COM&quot;, all.x = TRUE) Calculer les superficies des communes com_dens$superficie &lt;- st_area(com_dens) Convertir les unités des différentes mesures units(com_dens$superficie) &lt;- &quot;km^2&quot; units(com_dens$longueur) &lt;- &quot;km&quot; Calculer les indicateurs Le premier est le rapport entre la longueur des routes et la population des communes. com_dens$dens_pop &lt;- com_dens$longueur / com_dens$POPULATION plot(com_dens[&quot;dens_pop&quot;], main = &quot;km / hab&quot;) Le deuxième est le rapport entre la longueur des routes et la superficie des communes. com_dens$dens_sup &lt;- com_dens$longueur / com_dens$superficie plot(com_dens[&quot;dens_sup&quot;], main = &quot;km / km²&quot;) "],["georéférencement.html", "Chapitre 4 Georéférencement 4.1 Géocoder des adresses 4.2 Transformer les données long/lat en objet sf 4.3 Digitalisation", " Chapitre 4 Georéférencement 4.1 Géocoder des adresses Plusieurs packages permettent de géocoder des adresses. Le package tidygeocoder (Cambon et al. 2021) permet d’utiliser un grand nombre de services de géocodage en ligne. Le package banR (Gombin and Chevalier 2021), qui s’appuie sur la Base Adresse Nationale, est particulièrement approprié pour géocoder des adresses en France. 4.1.1 tidygeocoder library(tidygeocoder) mes_adresses &lt;- data.frame( address = c(&quot;10 Emma Goldmanweg, 5032MN Tilburg, Netherlands&quot;, &quot;Calle Mujeres Libres, 11510 Cadiz, Spain&quot;) ) places1 &lt;- geocode(mes_adresses, address) places1 # A tibble: 2 × 3 address lat long &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands 51.5 5.04 2 Calle Mujeres Libres, 11510 Cadiz, Spain 36.5 -6.17 Site web de tidygeocoder : tidygeocoder 4.1.2 banR # remotes::install_github(&quot;joelgombin/banR&quot;) library(banR) mes_adresses &lt;- data.frame( address = c(&quot;19 rue Michel Bakounine, 29600 Morlaix, France&quot;, &quot;2 Allee Emile Pouget, 920128 Boulogne-Billancourt&quot;) ) places2 &lt;- geocode_tbl(tbl = mes_adresses, adresse = address) places2 # A tibble: 2 × 17 address latitude longitude result_label result_score result_type result_id &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 19 rue Michel… 48.6 -3.82 19 Rue Michel Bak… 0.81 housenumber 29151_212… 2 2 Allee Emile… 48.8 2.24 2 Allee Emile Pou… 0.83 housenumber 92012_315… # … with 10 more variables: result_housenumber &lt;chr&gt;, result_name &lt;chr&gt;, # result_street &lt;chr&gt;, result_postcode &lt;chr&gt;, result_city &lt;chr&gt;, result_context &lt;chr&gt;, # result_citycode &lt;chr&gt;, result_oldcitycode &lt;chr&gt;, result_oldcity &lt;chr&gt;, # result_district &lt;chr&gt; Site web de banR : An R client for the BAN API 4.2 Transformer les données long/lat en objet sf La fonction st_as_sf() permet de transformer un data.frame contenant des coodonnées géographiques en objet sf. library(sf) place_sf &lt;- st_as_sf(places2, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) place_sf Simple feature collection with 2 features and 15 fields Geometry type: POINT Dimension: XY Bounding box: xmin: -3.816429 ymin: 48.59042 xmax: 2.239944 ymax: 48.83024 Geodetic CRS: WGS 84 # A tibble: 2 × 16 address result_label result_score result_type result_id result_housenum… result_name * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 19 rue M… 19 Rue Michel… 0.81 housenumber 29151_21… 19 Rue Michel… 2 2 Allee … 2 Allee Emile… 0.83 housenumber 92012_31… 2 Allee Emil… # … with 9 more variables: result_street &lt;chr&gt;, result_postcode &lt;chr&gt;, result_city &lt;chr&gt;, # result_context &lt;chr&gt;, result_citycode &lt;chr&gt;, result_oldcitycode &lt;chr&gt;, # result_oldcity &lt;chr&gt;, result_district &lt;chr&gt;, geometry &lt;POINT [°]&gt; Nous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud 2021a). library(maptiles) osm &lt;- get_tiles(x = place_sf, zoom = 7) plot_tiles(osm) plot(st_geometry(place_sf), pch = 4, cex = 2, col = &quot;red&quot;, add = TRUE) Focus sur OpenStreetMap 4.3 Digitalisation Le package mapedit (Appelhans, Russell, and Busetto 2020) permet de digitaliser des fonds de carte directement dans R. Bien que pouvant se révéler pratique dans certains cas, ce package ne saurait se substituer aux fonctionnalités d’un SIG pour les tâches de digitalisation importantes. Gif taken from mapedit website References "],["les-données-raster-le-package-terra.html", "Chapitre 5 Les données raster: le package terra 5.1 Import / export 5.2 Affichage 5.3 Modifications de la zone d’étude 5.4 Operations locales 5.5 Operations focales 5.6 Operations globales 5.7 Croisement raster/vecteur", " Chapitre 5 Les données raster: le package terra 5.1 Import / export 5.2 Affichage 5.3 Modifications de la zone d’étude 5.3.1 Projections 5.3.2 crop/ mask 5.3.3 aggreg 5.3.4 mosaic / merge 5.4 Operations locales 5.5 Operations focales 5.6 Operations globales 5.7 Croisement raster/vecteur passage vect &lt;=&gt; rast "],["osm.html", "Chapitre 6 Focus sur OpenStreetMap 6.1 Afficher une carte interactive 6.2 Importer les fonds de carte 6.3 Importer des données OSM 6.4 Calculer des itinéraires", " Chapitre 6 Focus sur OpenStreetMap OpenStreetMap (OSM) (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le monde entier. Conditions d’utilisation OpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…) Contributeurs (…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…) A propos d’OpenStreetMap 6.1 Afficher une carte interactive Les deux principaux packages qui permettent d’afficher une carte interactive basées sur OSM sont leaflet (Cheng, Karambelkar, and Xie 2018) et mapview (Appelhans et al. 2018). 6.1.1 leaflet leaflet utilise la libraire javascript Leaflet (Agafonkin 2015) pour créer des cartes interactives. library(sf) library(leaflet) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) # Sélection de la commune de Cahors cahors &lt;- com[com$INSEE_COM == &quot;46042&quot;, ] # Sélection des restaurants de Cahors restaurant_cahors &lt;- restaurant[restaurant$DEPCOM == &quot;46042&quot;, ] # transformation du système de coordonnées en WGS84 cahors &lt;- st_transform(cahors, 4326) restaurant_cahors &lt;- st_transform(restaurant_cahors, 4326) # Création de la carte interactive m &lt;- leaflet(cahors) %&gt;% addTiles() %&gt;% addPolygons() %&gt;% addMarkers(data = restaurant_cahors) m Site web de leaflet Leaflet for R 6.1.2 mapview mapview s’appuie sur leaflet pour créer des carte interactive, sont utilisation est plus simple et sa documentation est un peu dense. library(mapview) mapview(cahors) + mapview(restaurant_cahors) Site web de mapview mapview 6.2 Importer les fonds de carte Le package maptiles (Giraud 2021a) permet de télécharger et d’afficher des fonds de cartes raster. La fonction get_tiles() permet de télécharger des fonds de cartes OSM et la fonction plot_tiles() permet de les afficher. Les rendus sont meilleurs si les données en entrée utilisent le même système de coordonnées que les tuiles (EPSG:3857). library(sf) library(maptiles) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) com &lt;- st_transform(com, 3857) osm_tiles &lt;- get_tiles(x = com, zoom = 10, crop = TRUE) plot_tiles(osm_tiles) plot(st_geometry(com), border = &quot;grey20&quot;, lwd = .7, add = TRUE) mtext(side = 1, line = -1, text = get_credit(&quot;OpenStreetMap&quot;), col=&quot;tomato&quot;) 6.3 Importer des données OSM 6.3.1 osmdata Le package osmdata (Padgham et al. 2017) permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo. Site web du package osmdata library(sf) library(osmdata) library(sf) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) # Sélection de la commune de Cahors cahors &lt;- com[com$INSEE_COM == &quot;46042&quot;, ] # Définition d&#39;une bounding box q &lt;- opq(bbox = st_bbox(st_transform(cahors, 4326))) # Extraction des restaurants req &lt;- add_osm_feature(opq = q, key = &#39;amenity&#39;, value = &quot;restaurant&quot;) res &lt;- osmdata_sf(req) res Le résultat contient une couche de points et une couche de polygones. La couche de polygones contient des polygones qui représentent des restaurants. La couche de points contient des points qui représentent des restaurants (la valeur dans la colonne amenity est égale à “restaurant”) ET les points qui composent les polygones de la couche des polygones ((la valeur dans la colonne amenity est égale à NA). Pour obtenir une couche de points cohérente nous devons un peu travailler sur ces 2 couches. resto_point &lt;- res$osm_points # retirer les points qui composent les polygones resto_point &lt;- resto_point[!is.na(resto_point$amenity), ] # extraire les centroides des polygones resto_poly &lt;- res$osm_polygons resto_poly_point &lt;- st_centroid(resto_poly) # identifier les champs en commune chps &lt;- intersect(names(resto_point), names(resto_poly_point)) # rassembler les 2 objets resto &lt;- rbind(resto_point[, chps], resto_poly_point[, chps]) Affichage des résultats library(mapview) mapview(cahors) + mapview(resto) Site web d’osmdata osmdata 6.3.2 osmextract Le package osmextract (Gilardi and Lovelace 2021) permet d’extraire des données depuis une base de données OSM directement. Ce package permet de travailler sur des volumes de données très importants. Site web d’osmextract osmextract 6.4 Calculer des itinéraires Le package osrm (Giraud 2021b) sert d’interface entre R et le service de calcul d’itinéraire OSRM (Luxen and Vetter 2011). Ce package permet de calculer des matrices de temps et de distances, des itinéraires routiers, des isochrones. Le package utilise par défaut le serveur de démo d’OSRM. En cas d’utilisation intensive il est fortement recommandé d’utiliser sa propre instance d’OSRM (avec Docker). 6.4.1 Calcul d’un itinéraire La fonction osrmRoute() permet de calculer des itinéraires. library(sf) library(osrm) library(maptiles) com &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;commune&quot;, quiet = TRUE) com &lt;- st_transform(com, 3857) # Itinéraire entre Cahors et Puybrun cahors &lt;- com[com$INSEE_COM == &quot;46042&quot;, ] puybrun &lt;- com[com$INSEE_COM == &quot;46229&quot;, ] route &lt;- osrmRoute(src = cahors, dst = puybrun, returnclass = &quot;sf&quot;) osm &lt;- get_tiles(route, crop = TRUE) plot_tiles(osm) plot(st_geometry(route), col = &quot;grey10&quot;, lwd = 6, add = T) plot(st_geometry(route), col = &quot;grey90&quot;, lwd = 1, add = T) 6.4.2 Calcul d’une matrice de temps La fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route. Dans cet exemple nous calculons une matrice de temps entre 2 adresses et les restaurants de Cahors à pied. library(sf) library(tidygeocoder) restaurant &lt;- st_read(&quot;data/lot46.gpkg&quot;, layer = &quot;restaurant&quot;, quiet = TRUE) # Sélection des restaurants de Cahors restaurant_cahors &lt;- restaurant[restaurant$DEPCOM == &quot;46042&quot;, ] # geocodage de 2 adresses à Cahors adresses &lt;- data.frame(ad = c(&quot;3 rue Montaudié, Cahors, France&quot;, &quot;5 rue Albert Camus, Cahors, France&quot;) ) places &lt;- tidygeocoder::geocode(.tbl = adresses,address = ad) places # A tibble: 2 × 3 ad lat long &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 3 rue Montaudié, Cahors, France 44.5 1.45 2 5 rue Albert Camus, Cahors, France 44.5 1.43 # Calcul de la matrice de distance entre les 2 adresses et les restaurants de Cahors mat &lt;- osrmTable(src = places[, c(1,3,2)], dst = restaurant_cahors, osrm.profile = &quot;foot&quot;) mat$durations[1:2,1:5] 2382 2383 2384 2385 2386 3 rue Montaudié, Cahors, France 17.9 21.3 22.6 22.7 15.0 5 rue Albert Camus, Cahors, France 31.2 62.7 35.3 22.9 32.5 # Quelle adresse possède une meilleurs accessibilité aux restaurants de Cahors? boxplot(t(mat$durations[,]), cex.axis = .7) References "],["acquisition-de-données-spatiales.html", "Chapitre 7 Acquisition de données spatiales", " Chapitre 7 Acquisition de données spatiales packages ou api gadmr giscoR / eurostat naturalearth Package par territoire "],["sessioninfo.html", "Chapitre 8 sessionInfo()", " Chapitre 8 sessionInfo() R version 4.1.1 (2021-08-10) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Debian GNU/Linux 11 (bullseye) Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 locale: [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C LC_TIME=fr_FR.UTF-8 [4] LC_COLLATE=fr_FR.UTF-8 LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] osrm_3.5.0 osmdata_0.1.8 maptiles_0.3.0 banR_0.2.2 [5] tidygeocoder_1.0.4 mapview_2.10.0 leaflet_2.0.4.1 sf_1.0-3 [9] knitr_1.36 loaded via a namespace (and not attached): [1] httr_1.4.2 sass_0.4.0 jsonlite_1.7.2 [4] bslib_0.3.1 assertthat_0.2.1 highr_0.9 [7] sp_1.4-5 stats4_4.1.1 yaml_2.2.1 [10] pillar_1.6.3 lattice_0.20-44 glue_1.4.2 [13] uuid_0.1-4 digest_0.6.28 RColorBrewer_1.1-2 [16] rvest_1.0.2 colorspace_2.0-2 leaflet.providers_1.9.0 [19] htmltools_0.5.2 pkgconfig_2.0.3 raster_3.5-2 [22] bookdown_0.24 purrr_0.3.4 scales_1.1.1 [25] webshot_0.5.2 brew_1.0-6 svglite_2.0.0 [28] terra_1.4-11 satellite_1.0.4 tibble_3.1.5 [31] proxy_0.4-26 generics_0.1.0 ellipsis_0.3.2 [34] cli_3.0.1 magrittr_2.0.1 crayon_1.4.1 [37] evaluate_0.14 fansi_0.5.0 xml2_1.3.2 [40] class_7.3-19 tools_4.1.1 lifecycle_1.0.1 [43] stringr_1.4.0 munsell_0.5.0 compiler_4.1.1 [46] jquerylib_0.1.4 e1071_1.7-9 systemfonts_1.0.3 [49] rlang_0.4.11 classInt_0.4-3 units_0.7-2 [52] grid_4.1.1 leafpop_0.1.0 rstudioapi_0.13 [55] htmlwidgets_1.5.4 crosstalk_1.1.1 leafem_0.1.6 [58] base64enc_0.1-3 rmarkdown_2.11 codetools_0.2-18 [61] DBI_1.1.1 curl_4.3.2 R6_2.5.1 [64] lubridate_1.8.0 dplyr_1.0.7 fastmap_1.1.0 [67] utf8_1.2.2 KernSmooth_2.23-20 stringi_1.7.5 [70] Rcpp_1.0.7 vctrs_0.3.8 png_0.1-7 [73] tidyselect_1.1.1 xfun_0.26 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
