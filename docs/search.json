[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Géomatique avec R",
    "section": "",
    "text": "Préambule\nCe manuel est destiné tant aux utilisateurs de R souhaitant mettre en place des traitements de données spatiales qu’aux utilisateurs souhaitant utiliser R pour réaliser les taches qu’ils réalisent habituellement avec un SIG.\nLes principales étapes du traitement de l’information géographiques y sont abordées. L’accent est porté sur le traitement des données vectorielles mais une partie est tout de même dédiée aux données raster.\nComment utiliser le manuel\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nContribution et feedback\nVous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le dépôt GitHub de ce document.\nContexte\nCe manuel a été initialement conçu pour accompagner le cours “Cartographie avec R” du Master 2 Géomatique, géodécisionnel, géomarketing et multimédia (G2M) de l’Université Paris 8 Vincennes - Saint-Denis. Une version PDF est disponible ici : .\nUn deuxième manuel centré sur la cartographie est disponible ici : Cartographie avec R.\nVoir aussi en anglais : \n\n\n\n\n\n\n\n\n\nLovelace et al. (2019)\n\n\n\n\n\n\n\nPebesma et Bivand (2023)\n\n\n\n\n\n\n\nHijmans (2023)\n\n\n\n\n\n Pour citer le document :\nGiraud, T. et Pecout, H. (2024). Géomatique avec R. https://doi.org/10.5281/zenodo.5906212\n\n\n\n\n\nHijmans, R. J. (2023). Spatial Data Science with R and \"terra\". https://rspatial.org\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation with R. CRC Press. https://r.geocompx.org/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With applications in R (p. 352). Chapman and Hall/CRC. https://r-spatial.org/book/",
    "crumbs": [
      "*Préambule*"
    ]
  },
  {
    "objectID": "01_package_sf.html",
    "href": "01_package_sf.html",
    "title": "1  Le package sf",
    "section": "",
    "text": "1.1 Présentation\nLe package sf (Pebesma, 2018) a été publié fin 2016 par Edzer Pebesma. Ce package permet l’import, l’export, la manipulation et l’affichage de données spatiales vectorielles. Pour cela sf s’appuie sur une série de bibliothèques spatiales : GDAL (GDAL/OGR contributors, 2022) et PROJ (PROJ contributors, 2021) pour les opérations d’import, d’export et de projection, et GEOS (GEOS contributors, 2021) pour les opérations de géotraitement (buffer, intersection…).\nCe package propose des objets simples (suivant le standard simple feature) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe (|&gt; ou %&gt;%) et les opérateurs du tidyverse (Wickham et al., 2019).",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#présentation",
    "href": "01_package_sf.html#présentation",
    "title": "1  Le package sf",
    "section": "",
    "text": "Pebesma et Bivand (2023)\n\n\n\n\n\n\n\n\nHistorique\n\n\n\nLe package sf est venu remplacer les packages sp (Pebesma et Bivand, 2005), rgeos (Bivand et Rundel, 2023) et rgdal (Bivand et al., 2023) en combinant leurs fonctionnalités dans un package unique plus ergonomique. Sur ce sujet on peut lire avec profit l’article de Bivand (2021) qui évoque l’évolution de l’écosystème spatial de R.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#format-des-objets-sf",
    "href": "01_package_sf.html#format-des-objets-sf",
    "title": "1  Le package sf",
    "section": "1.2 Format des objets sf",
    "text": "1.2 Format des objets sf\n\nLes objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry).\nCe format est très pratique dans la mesure où les données et les géométries sont intrinsèquement liées dans un même objet.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#ressources",
    "href": "01_package_sf.html#ressources",
    "title": "1  Le package sf",
    "section": "1.3 Ressources",
    "text": "1.3 Ressources\n\n\n\n\n\n\n\n\n\nSite web de sf\n\n\n\n\n\n\n\nCheat sheet",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#exercice",
    "href": "01_package_sf.html#exercice",
    "title": "1  Le package sf",
    "section": "Exercice",
    "text": "Exercice\n\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nNous utiliserons principalement le package sf dans la suite de ce document.\nInstallez le en utilisant la fonction install.packages().\n\n\n\n\n\nBivand, R. (2021). Progress in the R ecosystem for representing and handling spatial data. Journal of Geographical Systems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate transformation software library. Open Source Geospatial Foundation. https://libgeos.org/\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data in R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With applications in R (p. 352). Chapman and Hall/CRC. https://r-spatial.org/book/\n\n\nPROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et al.Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html",
    "href": "02_import_sf.html",
    "title": "2  Import et export",
    "section": "",
    "text": "2.1 Import\nLes lignes suivantes importent la couche des communes du département du Lot mise à disposition dans le fichier geopackage lot.gpkg.\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.11.1, GDAL 3.6.2, PROJ 9.1.1; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prj/geomatique_avec_r/data/lot.gpkg' using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\nclass(com)\n\n#&gt; [1] \"sf\"         \"data.frame\"\nLa fonction st_read() importe les couches géographiques au format sf.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#import",
    "href": "02_import_sf.html#import",
    "title": "2  Import et export",
    "section": "",
    "text": "Geopackage\n\n\n\nLe format geopackage permet de stocker plusieurs couches dans un même fichier.\nLa fonction st_layers() permet d’avoir un aperçu des couches présentes dans un fichier geopackage.\n\nst_layers(\"data/lot.gpkg\")\n\n#&gt; Driver: GPKG \n#&gt; Available layers:\n#&gt;     layer_name geometry_type features fields              crs_name\n#&gt; 1     communes Multi Polygon      313     12 RGF93 v1 / Lambert-93\n#&gt; 2 departements Multi Polygon       96      5 RGF93 v1 / Lambert-93\n#&gt; 3  restaurants         Point      694      2 RGF93 v1 / Lambert-93\n#&gt; 4   elevations         Point     5228      1 RGF93 v1 / Lambert-93\n#&gt; 5       routes   Line String     1054      2 RGF93 v1 / Lambert-93",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#export",
    "href": "02_import_sf.html#export",
    "title": "2  Import et export",
    "section": "2.2 Export",
    "text": "2.2 Export\nLes lignes suivantes exportent l’objet com dans la couche communes du geopackage com.gpkg dans le dossier data.\n\nst_write(obj = com, dsn = \"data/com.gpkg\", layer = \"communes\")\n\n#&gt; Writing layer `communes' to data source `data/com.gpkg' using driver `GPKG'\n#&gt; Writing 313 features with 12 fields and geometry type Multi Polygon.\n\n\n\n\n\n\n\n\nConversion pour le package terra\n\n\n\nLa fonction vect() du package terra permet de transformer un objet sf en objet SpatVector.\n\nlibrary(terra)\n\n#&gt; terra 1.7.71\n\n# conversion\ncom2 &lt;- vect(com)\nclass(com2)\n\n#&gt; [1] \"SpatVector\"\n#&gt; attr(,\"package\")\n#&gt; [1] \"terra\"",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#exercice",
    "href": "02_import_sf.html#exercice",
    "title": "2  Import et export",
    "section": "Exercice",
    "text": "Exercice\nImportez la couche des restaurants depuis le fichier lot.gpkg dans un objet nommé “resto”.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html",
    "href": "03_affichage_sf.html",
    "title": "3  Exploration et affichage",
    "section": "",
    "text": "3.1 Aperçu des variables\nLes objets sf sont des data.frame.\nNous pouvons utiliser les fonctions head() ou summary().\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.11.1, GDAL 3.6.2, PROJ 9.1.1; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 MULTIPOLYGON (((593707.7 64...\n\nsummary(com)\n\n#&gt;   INSEE_COM           NOM_COM             STATUT            POPULATION     \n#&gt;  Length:313         Length:313         Length:313         Min.   :   49.0  \n#&gt;  Class :character   Class :character   Class :character   1st Qu.:  172.0  \n#&gt;  Mode  :character   Mode  :character   Mode  :character   Median :  300.0  \n#&gt;                                                           Mean   :  555.7  \n#&gt;                                                           3rd Qu.:  529.0  \n#&gt;                                                           Max.   :19907.0  \n#&gt;      AGR_H            AGR_F            IND_H             IND_F        \n#&gt;  Min.   : 0.000   Min.   : 0.000   Min.   :  0.000   Min.   :  0.000  \n#&gt;  1st Qu.: 0.000   1st Qu.: 0.000   1st Qu.:  4.843   1st Qu.:  0.000  \n#&gt;  Median : 5.000   Median : 0.000   Median :  5.516   Median :  4.943  \n#&gt;  Mean   : 6.935   Mean   : 2.594   Mean   : 16.395   Mean   :  7.635  \n#&gt;  3rd Qu.:10.013   3rd Qu.: 5.000   3rd Qu.: 19.715   3rd Qu.:  9.905  \n#&gt;  Max.   :56.179   Max.   :24.641   Max.   :602.867   Max.   :184.016  \n#&gt;      BTP_H             BTP_F             TER_H             TER_F        \n#&gt;  Min.   :  0.000   Min.   : 0.0000   Min.   :   0.00   Min.   :   0.00  \n#&gt;  1st Qu.:  0.000   1st Qu.: 0.0000   1st Qu.:  10.00   1st Qu.:  15.15  \n#&gt;  Median :  5.000   Median : 0.0000   Median :  20.00   Median :  30.26  \n#&gt;  Mean   :  9.572   Mean   : 0.9723   Mean   :  42.17   Mean   :  60.77  \n#&gt;  3rd Qu.: 10.329   3rd Qu.: 0.0000   3rd Qu.:  44.69   3rd Qu.:  63.95  \n#&gt;  Max.   :203.122   Max.   :16.9238   Max.   :1778.87   Max.   :2397.18  \n#&gt;             geom    \n#&gt;  MULTIPOLYGON :313  \n#&gt;  epsg:2154    :  0  \n#&gt;  +proj=lcc ...:  0  \n#&gt;                     \n#&gt;                     \n#&gt;",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#aperçu-des-variables",
    "href": "03_affichage_sf.html#aperçu-des-variables",
    "title": "3  Exploration et affichage",
    "section": "",
    "text": "Supprimer la colonne de géométrie d’un objet sf\n\n\n\nPour transformer un objet sf en simple data.frame (sans géométries), nous pouvons utiliser les fonctions st_set_geometry() ou st_drop_geometry().\n\ncom_df1 &lt;- st_set_geometry(com, NULL)\ncom_df2 &lt;- st_drop_geometry(com)\nidentical(com_df1, com_df2)\n\n#&gt; [1] TRUE\n\nhead(com_df1, n = 3)\n\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#affichage",
    "href": "03_affichage_sf.html#affichage",
    "title": "3  Exploration et affichage",
    "section": "3.2 Affichage",
    "text": "3.2 Affichage\nAperçu des variables avec plot() :\n\nplot(com)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\n\n\n\n\nAffichage d’une seule variable :\n\nplot(com[\"POPULATION\"])\n\n\n\n\n\n\n\n\nAffichage de la géométrie seule :\n\nplot(st_geometry(com), col = \"ivory4\", border = \"ivory\")\n\n\n\n\n\n\n\n\nIl est aussi possible d’utiliser le package mapsf (Giraud, 2023) pour afficher les objets sf.\n\nlibrary(mapsf)\nmf_map(com, col = \"ivory4\", border = \"ivory\")",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#exercice",
    "href": "03_affichage_sf.html#exercice",
    "title": "3  Exploration et affichage",
    "section": "Exercice",
    "text": "Exercice\nAffichez les communes et les restaurants sur une même carte.\n\n\n\n\nGiraud, T. (2023). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "04_projection_sf.html",
    "href": "04_projection_sf.html",
    "title": "4  Les systèmes de coordonnées",
    "section": "",
    "text": "4.1 Consulter le système de coordonnées d’un objet\nLa fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf.\nlibrary(sf) \nst_crs(x = com)\n\n#&gt; Coordinate Reference System:\n#&gt;   User input: RGF93 v1 / Lambert-93 \n#&gt;   wkt:\n#&gt; PROJCRS[\"RGF93 v1 / Lambert-93\",\n#&gt;     BASEGEOGCRS[\"RGF93 v1\",\n#&gt;         DATUM[\"Reseau Geodesique Francais 1993 v1\",\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4171]],\n#&gt;     CONVERSION[\"Lambert-93\",\n#&gt;         METHOD[\"Lambert Conic Conformal (2SP)\",\n#&gt;             ID[\"EPSG\",9802]],\n#&gt;         PARAMETER[\"Latitude of false origin\",46.5,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8821]],\n#&gt;         PARAMETER[\"Longitude of false origin\",3,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8822]],\n#&gt;         PARAMETER[\"Latitude of 1st standard parallel\",49,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8823]],\n#&gt;         PARAMETER[\"Latitude of 2nd standard parallel\",44,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8824]],\n#&gt;         PARAMETER[\"Easting at false origin\",700000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8826]],\n#&gt;         PARAMETER[\"Northing at false origin\",6600000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8827]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Engineering survey, topographic mapping.\"],\n#&gt;         AREA[\"France - onshore and offshore, mainland and Corsica (France métropolitaine including Corsica).\"],\n#&gt;         BBOX[41.15,-9.86,51.56,10.38]],\n#&gt;     ID[\"EPSG\",2154]]",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les systèmes de coordonnées</span>"
    ]
  },
  {
    "objectID": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "href": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "title": "4  Les systèmes de coordonnées",
    "section": "4.2 Modifier le système de coordonnées d’un objet",
    "text": "4.2 Modifier le système de coordonnées d’un objet\nLa fonction st_transform() permet de changer le système de coordonnées d’un objet sf, de le reprojeter.\nmf_map(com, expandBB = c(0, .12, 0, 0))\nmf_graticule(x = com)\nmf_title(\"RGF93 / Lambert-93\")\n# changement de projection\ncom_reproj &lt;- st_transform(x = com, crs = \"EPSG:3035\")\n\nmf_map(com_reproj, expandBB = c(0, .12, .0, 0))\nmf_graticule(x = com_reproj)\nmf_title(\"ETRS89-extended / LAEA Europe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi l’on souhaite projeter un objet spatial utilisant des coordonnées géographiques (lon/lat), le package crsuggest (Walker, 2022) propose des projections adaptées à l’emprise de l’objet.\nLe site CRS Explorer met à disposition les références de très nombreux systèmes coordonnées.\n\n\n\n\n\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference System Information for Spatial Data. https://CRAN.R-project.org/package=crsuggest",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les systèmes de coordonnées</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html",
    "href": "05_selection_attrib_sf.html",
    "title": "5  Sélection et jointure attributaire",
    "section": "",
    "text": "5.1 Sélection par attributs\nLes objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame.\n# sélection de lignes\ncom[1:2, ]\n\n#&gt; Simple feature collection with 2 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H IND_F\n#&gt; 1     46001   Albas Commune simple        522 4.978581 0.000000 4.936153     0\n#&gt; 2     46002  Albiac Commune simple         67 0.000000 9.589041 0.000000     0\n#&gt;      BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n\ncom[com$NOM_COM == \"Gramat\", ]\n\n#&gt; Simple feature collection with 1 feature and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H\n#&gt; 119     46128  Gramat Commune simple       3468 10.19868 15.29802 122.3842\n#&gt;        IND_F    BTP_H BTP_F    TER_H    TER_F                           geom\n#&gt; 119 107.0862 56.09275     0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64...\n\n# sélection de colonnes\ncom[, \"POPULATION\"]\n\n#&gt; Simple feature collection with 313 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    POPULATION                           geom\n#&gt; 1         522 MULTIPOLYGON (((559262 6371...\n#&gt; 2          67 MULTIPOLYGON (((605540.7 64...\n#&gt; 3         706 MULTIPOLYGON (((593707.7 64...\n#&gt; 4         219 MULTIPOLYGON (((613211.3 64...\n#&gt; 5         329 MULTIPOLYGON (((556744.9 63...\n#&gt; 6         377 MULTIPOLYGON (((576667.2 64...\n#&gt; 7         988 MULTIPOLYGON (((581404 6370...\n#&gt; 8         203 MULTIPOLYGON (((558216 6389...\n#&gt; 9         642 MULTIPOLYGON (((612729.6 63...\n#&gt; 10        367 MULTIPOLYGON (((581404 6370...\n\ncom[com$NOM_COM == \"Gramat\", 1:4]\n\n#&gt; Simple feature collection with 1 feature and 4 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION                           geom\n#&gt; 119     46128  Gramat Commune simple       3468 MULTIPOLYGON (((594713.1 64...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html#jointure-attributaire",
    "href": "05_selection_attrib_sf.html#jointure-attributaire",
    "title": "5  Sélection et jointure attributaire",
    "section": "5.2 Jointure attributaire",
    "text": "5.2 Jointure attributaire\nNous pouvons joindre un data.frame à un objet sf en utilisant la fonction merge() et en s’appuyant sur des identifiants communs aux deux objets.\nAttention à l’ordre des arguments, l’objet retourné sera du même type que x. Il n’est pas possible de faire une jointure attributaire en utilisant deux objets sf.\n\n# import de données supplémentaires \ncom_df &lt;- read.csv(file = \"data/com.csv\")\n\n# des identifiants en commun?\nnames(com_df)\n\n#&gt; [1] \"INSEE_COM\" \"ACT\"       \"IND\"       \"SACT\"      \"SACT_IND\"\n\nnames(com)\n\n#&gt;  [1] \"INSEE_COM\"  \"NOM_COM\"    \"STATUT\"     \"POPULATION\" \"AGR_H\"     \n#&gt;  [6] \"AGR_F\"      \"IND_H\"      \"IND_F\"      \"BTP_H\"      \"BTP_F\"     \n#&gt; [11] \"TER_H\"      \"TER_F\"      \"geom\"\n\n# jointure attributaire \ncom_final &lt;- merge(\n  x = com,             # l'objet sf\n  y = com_df,          # le data.frame\n  by.x = \"INSEE_COM\",  # identifiant dans x\n  by.y = \"INSEE_COM\",  # identifiant dans y\n  all.x = TRUE         # conserver toutes les lignes\n)\n\n# Les deux objets ont bien été joints\nhead(com_final, 3)\n\n#&gt; Simple feature collection with 3 features and 16 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F       ACT       IND     SACT\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799  99.47120  4.936153 19.05579\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041  28.76712  0.000000 42.93600\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 171.92475 15.629522 24.35195\n#&gt;   SACT_IND                       geometry\n#&gt; 1 4.962393 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 9.090909 MULTIPOLYGON (((593707.7 64...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html#exercice",
    "href": "05_selection_attrib_sf.html#exercice",
    "title": "5  Sélection et jointure attributaire",
    "section": "Exercice",
    "text": "Exercice\n\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du Lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nla part des actifs dans la population totale (SACT)\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nSélectionnez les communes du Lot ayant plus de 500 actifs et dont la part des actifs dans la population totale est supérieure à 30%.\nAffichez toutes les communes en gris et les communes sélectionnées en rouge.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html",
    "href": "06_selection_jointure_spatiale_sf.html",
    "title": "6  Sélection et jointure spatiale",
    "section": "",
    "text": "6.1 Sélection spatiale\nLa fonction st_filter() permet d’effectuer des sélections spatiales. L’argument .predicate permet de choisir sur quel critère se fait la selection en utilisant l’une des fonctions de “predicat géométrique” (par exemple st_intersects(), st_within(), st_crosses()…).\nNous allons ici sélectionner les routes qui intersectent la commune de Gramat\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\ngramat &lt;-  com[com$NOM_COM == \"Gramat\", ]\n      \nroute_gramat &lt;-  st_filter(x = route, \n                           y = gramat,\n                           .predicate = st_intersects)\n\n# Affichage     \nmf_map(gramat, col = \"lightblue\")\nmf_map(route, add = TRUE)\nmf_map(route_gramat, col = \"tomato\", lwd = 2, add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "href": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "title": "6  Sélection et jointure spatiale",
    "section": "6.2 Jointure spatiale",
    "text": "6.2 Jointure spatiale\nLa fonction st_join() permet de réaliser des jointures spatiales. Cette fois-ci c’est l’argument join qui utilise une fonction de prédicat géométrique.\n\nroute_gramat &lt;-  st_join(x = route,\n                         y = com[, \"INSEE_COM\"],\n                         join = st_intersects,\n                         left = FALSE)\nroute_gramat\n\n#&gt; Simple feature collection with 1247 features and 3 fields\n#&gt; Geometry type: LINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 587147.6 ymin: 6394844 xmax: 608194.7 ymax: 6420006\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;     ID      CLASS_ADM INSEE_COM                           geom\n#&gt; 1    1 Départementale     46240 LINESTRING (590557.5 641181...\n#&gt; 2    2 Départementale     46240 LINESTRING (593733.2 641429...\n#&gt; 3    3 Départementale     46240 LINESTRING (590665 6412381,...\n#&gt; 4    4 Départementale     46128 LINESTRING (598940.9 640909...\n#&gt; 5    5 Départementale     46104 LINESTRING (603201.9 640181...\n#&gt; 6    6     Sans objet     46235 LINESTRING (598162.3 640108...\n#&gt; 7    7 Départementale     46090 LINESTRING (598887.3 639763...\n#&gt; 7.1  7 Départementale     46138 LINESTRING (598887.3 639763...\n#&gt; 7.2  7 Départementale     46233 LINESTRING (598887.3 639763...\n#&gt; 8    8 Départementale     46090 LINESTRING (601184.3 639697...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#exercice",
    "href": "06_selection_jointure_spatiale_sf.html#exercice",
    "title": "6  Sélection et jointure spatiale",
    "section": "Exercice",
    "text": "Exercice\n\nImportez la couche des communes et celle des restaurants du Lot.\nRéaliser une jointure spatiale pour connaitre pour chaque restaurant le nom et l’identifiant de la commune dans laquelle il se trouve.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html",
    "href": "07_operation_geom_sf.html",
    "title": "7  Opérations sur les géométries",
    "section": "",
    "text": "7.1 Extraire des centroides\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmf_map(com)\nmf_map(com_c, add = TRUE, cex = 1.2, col = \"red\", pch = 20)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones",
    "href": "07_operation_geom_sf.html#agréger-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.2 Agréger des polygones",
    "text": "7.2 Agréger des polygones\n\ndep_46 &lt;- st_union(com)\n\nmf_map(com, col = \"lightblue\")\nmf_map(dep_46, col = NA, border = \"red\", lwd = 2, add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "href": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "title": "7  Opérations sur les géométries",
    "section": "7.3 Agréger des polygones en fonction d’une variable",
    "text": "7.3 Agréger des polygones en fonction d’une variable\n\nAvec la fonction tapply()\n\n\n# variable servant à agréger les polygones\ni &lt;- com$STATUT \n\ncom_u &lt;- st_sf(\n  STATUT     = tapply(X = com$STATUT     , INDEX = i, FUN = head, 1),\n  POPULATION = tapply(X = com$POPULATION , INDEX = i, FUN = sum), \n  geometry   = tapply(X = com            , INDEX = i, FUN = st_union), \n  crs        = st_crs(com)\n) \n\n\n\n\n\n\n\nExplication de la méthode d’agrégation\n\n\n\n\n\ntapply(X, INDEX, FUN) permet d’aggréger une variable en fonction d’une autre.\nIl faut indiquer la variable à agréger X, la variable servant à agréger INDEX et la manière d’agréger (la fonction d’agrégation) FUN.\nIci par exemple nous calculons la somme des population des communes en fonction de leur statut :\n\ntapply(X = com$POPULATION, INDEX = com$STATUT, FUN = sum)\n\n#&gt;  Commune simple      Préfecture Sous-préfecture \n#&gt;          140259           19907           13763\n\n\ntapply() fonctionne également avec les objets sf et sfc:\n\nst_sf(geometry = st_sfc(tapply(com, com$STATUT, st_union)))\n\n#&gt; Simple feature collection with 3 features and 0 fields\n#&gt; Geometry type: GEOMETRY\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; CRS:           NA\n#&gt;                         geometry\n#&gt; 1 POLYGON ((554732.7 6356281,...\n#&gt; 2 MULTIPOLYGON (((580994.5 63...\n#&gt; 3 MULTIPOLYGON (((626296.4 63...\n\n\nNous pouvons ensuite combiner plusieurs appels tapply() à l’interieur d’un appel à st_sf() en ajoutant également les informations sur le système de coordonnées.\n\nst_sf(\n  STATUT     = tapply(com$STATUT    , com$STATUT, head, 1), # identifiants\n  POPULATION = tapply(com$POPULATION, com$STATUT, sum),     # somme des populations\n  geometry   = tapply(com           , com$STATUT, st_union),# union des géométries \n  crs        = st_crs(com)                                  # information sur le CRS\n) \n\n#&gt; Simple feature collection with 3 features and 2 fields\n#&gt; Geometry type: GEOMETRY\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;            STATUT POPULATION                       geometry\n#&gt; 1  Commune simple     140259 POLYGON ((554732.7 6356281,...\n#&gt; 2      Préfecture      19907 MULTIPOLYGON (((580994.5 63...\n#&gt; 3 Sous-préfecture      13763 MULTIPOLYGON (((626296.4 63...\n\n\n\n\n\n\n\n\n\n\n\nL’avantage de cette solution est qu’elle permet d’agréger les variables attributaires avec des fonctions d’agrégation différentes. Nous pouvons par exemple utiliser la somme pour une population (un stock) et la moyenne pour un taux de chômage (un ratio).\n\n\n\n\nAvec la fonction aggregate()\n\n\ncom_u &lt;- aggregate(\n  x = com[\"POPULATION\"], \n  by = list(STATUT = com$STATUT), \n  FUN = sum\n)\n\n\n\n\n\n\n\nCette solution ne permettra pas d’agréger les variables attributaires avec des fonctions d’agrégation différentes. Nous devons donc choisir avec précaution en amont les variables que l’on souhaite agréger et leur fonction d’agrégation.\n\n\n\n\nAvec la bibliothèque dplyr\n\n\nlibrary(dplyr)\n\ncom_u &lt;- com |&gt;\n  group_by(STATUT) |&gt;\n  summarise(POPULATION = sum(POPULATION))",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "href": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "title": "7  Opérations sur les géométries",
    "section": "7.4 Construire une zone tampon",
    "text": "7.4 Construire une zone tampon\nLa fonction st_buffer() permet de construire des zones tampons. La distance est exprimée en unité de la projection utilisée (st_crs(x)$units).\n\ngramat &lt;- com[com$NOM_COM == \"Gramat\", ]\n\ngramat_b &lt;- st_buffer(x = gramat, dist = 5000)\n\nmf_map(gramat_b, col = \"lightblue\", lwd=2, border = \"red\")\nmf_map(gramat, add = TRUE, lwd = 2)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#réaliser-une-intersection",
    "href": "07_operation_geom_sf.html#réaliser-une-intersection",
    "title": "7  Opérations sur les géométries",
    "section": "7.5 Réaliser une intersection",
    "text": "7.5 Réaliser une intersection\nEn utilisant la fonction st_intersection(), on peut découper une couche par une autre.\n\n# création d'une zone tampon autour du centroide de la commune de Gramat\nzone &lt;- st_geometry(gramat) |&gt; \n  st_centroid() |&gt; \n  st_buffer(10000)\n\nmf_map(com)\nmf_map(zone, border = \"red\", col = NA, lwd = 2, add = TRUE)\n\n\n\n\n\n\n\ncom_z &lt;- st_intersection(x = com, y = zone)\n\n#&gt; Warning: attribute variables are assumed to be spatially constant throughout\n#&gt; all geometries\n\nmf_map(com)\nmf_map(com_z, col = \"red\", border = \"green\", add = TRUE)\n\n\n\n\n\n\n\nmf_map(com_z)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDans cette exemple nous avons utilisé les pipes (|&gt;). Les pipes permettent d’enchaîner une suite d’instructions.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "href": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "title": "7  Opérations sur les géométries",
    "section": "7.6 Créer une grille régulière",
    "text": "7.6 Créer une grille régulière\nLa fonction st_make_grid() permet de créer une grille régulière. La fonction produit un objet sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques.\n\n# Création de la grille\ngrid &lt;- st_make_grid(x = com, cellsize = 5000)\n\n# Ajout d'un identifiant unique\ngrid &lt;- st_sf(ID = 1:length(grid), geom = grid)\n\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(com, col = NA, border = \"grey50\", add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "href": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "title": "7  Opérations sur les géométries",
    "section": "7.7 Compter des points dans un polygone",
    "text": "7.7 Compter des points dans un polygone\nSélection des carreaux de la grille qui intersectent le département avec st_filter().\n\ngrid &lt;- st_filter(grid, dep_46, .predicate = st_intersects)\n\n# Import d'une couche géographique ponctuelle des restaurants du Lot\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(restaurant, pch = 20, col = \"red\", cex = .5, add = TRUE)\n\n\n\n\n\n\n\n\nNous utilisons ensuite la fonction st_intersects(..., sparse = TRUE) qui nous permettra d’avoir pour chaque élément de l’objet grid la liste des éléments (via leurs indexes) de l’objet restaurant qui se trouvent à l’intérieur.\n\ninter &lt;- st_intersects(grid, restaurant, sparse = TRUE)\n\nlength(inter) == nrow(grid)\n\n#&gt; [1] TRUE\n\n\nPour compter le nombre de restaurants il suffit donc de reporter la longueur de chacun des éléments de cette liste.\n\ngrid$nb_restaurant &lt;- lengths(inter)\n\nmf_map(grid)\nmf_map(grid, var = \"nb_restaurant\", type = \"prop\")\n\n#&gt; 94 '0' values are not plotted on the map.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-les-valeurs-de-points-dans-des-polygones",
    "href": "07_operation_geom_sf.html#agréger-les-valeurs-de-points-dans-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.8 Agréger les valeurs de points dans des polygones",
    "text": "7.8 Agréger les valeurs de points dans des polygones\nIci nous voulons résumer l’information contenue dans une couche de points dans des polygones. Nous voulons connaître l’altitude minimale et maximale de chaque communes.\nNous commencons par importer une couche de points d’altitude, la couche elevations du fichier lot.gpkg.\n\nelev &lt;- st_read(\"data/lot.gpkg\", \"elevations\", quiet = TRUE)\n\nmf_map(elev, \"elevation\", \"choro\", \n       breaks = c(80, seq(100, 700, by = 100), 742),\n       pal = hcl.colors(8, \"Terrain2\"), \n       pch = 21, leg_pos = \"topleft\", cex = .75)\n\n\n\n\n\n\n\n\nL’objectif est d’agréger les valeurs de ces points (les altitudes contenues dans le champ elevation) dans les communes du Lot.\nEn utilisant la fonction st_join() nous pouvons récupérer les attributs des communes dans lesquelles se trouvent les points.\n\ninter &lt;- st_join(x = elev, y = com[, \"INSEE_COM\"])\ninter\n\n#&gt; Simple feature collection with 5228 features and 2 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 540333.3 ymin: 6347372 xmax: 637333.3 ymax: 6439372\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    elevation INSEE_COM                     geom\n#&gt; 1   308.8546     46083 POINT (584333.3 6439372)\n#&gt; 2   304.6855     46083 POINT (582333.3 6438372)\n#&gt; 3   290.6638     46083 POINT (583333.3 6438372)\n#&gt; 4   295.0353     46083 POINT (584333.3 6438372)\n#&gt; 5   297.6773     46083 POINT (587333.3 6438372)\n#&gt; 6   257.7393     46083 POINT (588333.3 6438372)\n#&gt; 7   310.1883     46083 POINT (580333.3 6437372)\n#&gt; 8   305.0571     46083 POINT (581333.3 6437372)\n#&gt; 9   298.5876     46083 POINT (582333.3 6437372)\n#&gt; 10  287.6990     46083 POINT (583333.3 6437372)\n\n\nNous pouvons ensuite utiliser la fonction aggregate() pour agréger les altitudes par communes, d’abord l’altitude minimale, puis l’altitude maximale.\n\n# x   : la variable que l'on veut agréger\n# by  : la variable qui servira à agréger \n# FUN : la fonction à utiliser lors de l'agrégation\nalti_min &lt;- aggregate(x   = list(alt_min   = inter$elevation),    \n                      by  = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"min\")\n\nalti_max &lt;- aggregate(x   = list(alt_max   = inter$elevation),\n                      by  = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"max\")\n\nhead(alti_max, n = 3)\n\n#&gt;   INSEE_COM  alt_max\n#&gt; 1     46001 302.4913\n#&gt; 2     46002 393.9218\n#&gt; 3     46003 376.6632\n\n\nOn peut ensuite combiner ces résultats à la couche des communes (avec la fonction merge()).\n\ncom &lt;- merge(com, alti_min, by = \"INSEE_COM\", all.x = TRUE)\ncom &lt;- merge(com, alti_max, by = \"INSEE_COM\", all.x = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 14 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F  alt_min  alt_max\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 109.5772 302.4913\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 363.4579 393.9218\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 258.8378 376.6632\n#&gt;                         geometry\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n\n\nbks &lt;- c(80, seq(100, 700, by = 100), 742)\ncols &lt;- hcl.colors(8, \"Terrain2\")\n\nmf_map(com, \"alt_min\", \"choro\", breaks = bks, pal = cols)\nmf_map(com, \"alt_max\", \"choro\", breaks = bks, pal = cols)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#simplifier-des-géométries",
    "href": "07_operation_geom_sf.html#simplifier-des-géométries",
    "title": "7  Opérations sur les géométries",
    "section": "7.9 Simplifier des géométries",
    "text": "7.9 Simplifier des géométries\n Le package rmapshaper (Teucher et Russell, 2023) s’appuie sur la bibliothèque JavaScript Mapshaper (Bloch, 2013) pour proposer plusieurs méthodes de simplification des géométries qui respectent la topologie.\nL’argument keep permet d’indiquer le niveau de simplification. L’argument keep_shapes permet de conserver tous les polygones quand le niveau de simplification est élevé.\nlibrary(\"rmapshaper\")\ncom_simp1 &lt;- ms_simplify(com, keep = 0.01 , keep_shapes = TRUE)\ncom_simp2 &lt;- ms_simplify(com, keep = 0.001, keep_shapes = TRUE)\nmf_map(com)\nmf_map(com_simp1)\nmf_map(com_simp2)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#exercice",
    "href": "07_operation_geom_sf.html#exercice",
    "title": "7  Opérations sur les géométries",
    "section": "Exercice",
    "text": "Exercice\n\nCalculez le nombre de restaurants par commune.\nQuelles communes ont plus de 10 restaurants et moins de 1000 habitants ?\nCréez une carte où vous afficherez toutes les communes en gris et les communes sélectionnées plus haut en rouge.\n\n\n\n\n\nBloch, M. (2013). Mapshaper: Tools for editing Shapefile, GeoJSON, TopoJSON and CSV files JavaScript libary. https://github.com/mbloch/mapshaper\n\n\nTeucher, A. et Russell, K. (2023). rmapshaper: Client for ’mapshaper’ for ’Geospatial’ Operations. https://CRAN.R-project.org/package=rmapshaper",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html",
    "href": "08_mesures_sf.html",
    "title": "8  Mesures",
    "section": "",
    "text": "8.1 Créer une matrice de distances\nLa fonction st_distance() permet de calculer une matrice de distance entre deux couches de points.\nSi le système de projection du jeu de données est renseigné, les distances sont exprimées dans l’unité de mesure de la projection (le plus souvent en mètres).\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE, agr = \"constant\")\n# transformation de la couche com en couche de points\ncom_c &lt;- st_centroid(com)\nmat &lt;- st_distance(x = com_c, y = com_c)\nmat[1:5,1:5]\n\n#&gt; Units: [m]\n#&gt;           [,1]     [,2]     [,3]     [,4]      [,5]\n#&gt; [1,]     0.000 56784.77 54353.94 61166.42  3790.688\n#&gt; [2,] 56784.770     0.00 12454.29  7146.11 57288.103\n#&gt; [3,] 54353.942 12454.29     0.00 19388.52 54030.811\n#&gt; [4,] 61166.418  7146.11 19388.52     0.00 62016.141\n#&gt; [5,]  3790.688 57288.10 54030.81 62016.14     0.000",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html#calcul-de-superficies",
    "href": "08_mesures_sf.html#calcul-de-superficies",
    "title": "8  Mesures",
    "section": "8.2 Calcul de superficies",
    "text": "8.2 Calcul de superficies\nLa fonction st_area() permet de calculer des superficies.\n\nst_area(com[1:5, ])\n\n#&gt; Units: [m^2]\n#&gt; [1] 21721665  3813205 13024216  9993074  5540367",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html#convertir-des-unités",
    "href": "08_mesures_sf.html#convertir-des-unités",
    "title": "8  Mesures",
    "section": "8.3 Convertir des unités",
    "text": "8.3 Convertir des unités\nLe package units (Pebesma et al., 2016) permet de définir et convertir facilement des unités de mesure.\nLe package peut se révéler assez utile quand nous manipulons différentes unités de mesures régulièrement.\n\nlibrary(units)\n\n#&gt; udunits database from /usr/share/xml/udunits/udunits2.xml\n\ndistances &lt;- c(1, 2, 3, 5, 0.5)\nsurfaces &lt;- c(500, 1000, 10000, 20000)\n\n# définition des unités de mesure initiales\ndistances &lt;- set_units(distances, \"km\")\ndistances\n\n#&gt; Units: [km]\n#&gt; [1] 1.0 2.0 3.0 5.0 0.5\n\nsurfaces &lt;- set_units(surfaces, \"m2\")\nsurfaces\n\n#&gt; Units: [m^2]\n#&gt; [1]   500  1000 10000 20000\n\n# transformation des unités de mesure\ndistances &lt;- set_units(distances, \"m\")\ndistances\n\n#&gt; Units: [m]\n#&gt; [1] 1000 2000 3000 5000  500\n\nsurfaces &lt;- set_units(surfaces, \"ha\")\nsurfaces\n\n#&gt; Units: [ha]\n#&gt; [1] 0.05 0.10 1.00 2.00\n\n## Suppression des unités\ndistances &lt;- set_units(distances, NULL)\ndistances\n\n#&gt; [1] 1000 2000 3000 5000  500\n\nsurfaces &lt;- set_units(surfaces, NULL)\nsurfaces\n\n#&gt; [1] 0.05 0.10 1.00 2.00\n\n\n\n\n\n\nPebesma, E., Mailund, T. et Hiebert, J. (2016). Measurement Units in R. R Journal, 8(2), 486‑494. https://doi.org/10.32614/RJ-2016-061",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html",
    "href": "09_package_terra.html",
    "title": "9  Le package terra",
    "section": "",
    "text": "9.1 Présentation\nL’objectif du package terra (Hijmans, 2023) est de proposer des méthodes de traitement et d’analyse de données raster. Ce package est très similaire au package raster, mais il propose plus de fonctionnalités. Il est plus rapide et plus facile à utiliser.\nCe chapitre est largement inspiré de deux présentations (Madelin, 2021 ; Nowosad, 2021) réalisées dans le cadre de l’école thématique “Science de l’Information Géographique Reproductibles 2021” (SIGR2021).",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html#présentation",
    "href": "09_package_terra.html#présentation",
    "title": "9  Le package terra",
    "section": "",
    "text": "Site web du package terra :\n\n\n\nSpatial Data Science with R and “terra”",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html#format-des-objets-spatraster",
    "href": "09_package_terra.html#format-des-objets-spatraster",
    "title": "9  Le package terra",
    "section": "9.2 Format des objets SpatRaster",
    "text": "9.2 Format des objets SpatRaster\nLe package terra (Hijmans, 2023) permet de gérer des données vectorielles et raster. Pour manipuler ces données spatiales, terra les stockent dans des objets de type SpatVector et SpatRaster. Dans ce document, nous nous focalisons sur la manipulation de données raster (SpatRaster) à partir de fonctions proposées par ce package.\nUn objet SpatRaster représente des données matricielles, en une ou plusieurs couches (variables). Cet objet stocke également un certain nombre de paramètres fondamentaux qui le décrivent (nombre de colonnes, de lignes, étendue spatiale, système de référence des coordonnées…).\n\n\n\nRacine (2016)\n\n\n\n\n\n\nHijmans, R. J. (2023). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "10_import_terra.html",
    "href": "10_import_terra.html",
    "title": "10  Import et export",
    "section": "",
    "text": "10.1 Import\nLa fonction rast() permet de créer et/ou d’importer des données raster. Les lignes suivantes importent le fichier raster elevation.tif (Tagged Image File Format) au format d’objet SpatRaster.\nelev &lt;- rast(\"data/elevation.tif\") \nelev\n\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 987, 1300, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.0002972796, 0.0002972796  (x, y)\n#&gt; extent      : 1.245749, 1.632213, 44.30927, 44.60269  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source      : elevation.tif \n#&gt; name        : altitude \n#&gt; min value   :       91 \n#&gt; max value   :      421",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "10_import_terra.html#export",
    "href": "10_import_terra.html#export",
    "title": "10  Import et export",
    "section": "10.2 Export",
    "text": "10.2 Export\nLa fonction writeRaster() permet d’enregistrer un objet SpatRaster sur votre machine, dans le format de votre choix.\n\nwriteRaster(x = elev, filename = \"data/new_elevation_Lot.tif\")\n\n\n\n\n\n\n\nConversion pour le package sf\n\n\n\nLe package terra permet de manipuler des objets vectoriels en utilisant des objets de type SpatVector.\nLa fonction st_as_sf() du package sf permet de transformer un objet SpatVector en objet sf.\n\n# adresse du fichier d'exemple\nf &lt;- system.file(\"ex/lux.shp\", package=\"terra\")\n# import au format SpatVector\nv &lt;- vect(f)\nlibrary(sf)\n# conversion\nv2 &lt;- st_as_sf(v)\nclass(v2)\n\n#&gt; [1] \"sf\"         \"data.frame\"\n\n\n\n\n\n\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "11_affichage_terra.html",
    "href": "11_affichage_terra.html",
    "title": "11  Affichage",
    "section": "",
    "text": "La fonction plot() permet d’afficher un objet SpatRaster.\n\nlibrary(terra)\n\n#&gt; terra 1.7.71\n\nelev &lt;- rast(\"data/elevation.tif\") \nplot(elev)\n\n\n\n\n\n\n\n\nUn raster contient toujours des données numériques, mais il peut aussi bien s’agir de données quantitatives que de données qualitatives (catégorielles) codées numériquement.\nPrécisez le type de données stockées avec l’argument type (type = \"continuous\" par défaut), pour les afficher correctement.\nImport et affichage d’un raster contenant des données catégorielles : CORINE Land Cover 2018 (type d’occupation du sol) avec une résolution de 100m. Ces données ont été récupérées sur le site de Copernicus, le programme européen de surveillance de la Terre qui collecte et met à disposition des données issues de ses propres satellites (Sentinelles) d’observation. Une extraction centrée sur la commune de Cahors a ensuite été réalisée.\n\nclc &lt;- rast(\"data/clc_2018.tif\")\n\n# Affichage\nplot(clc, type=\"classes\")\n\n\n\n\n\n\n\n\nPour afficher les intitulés réels des types d’occupation du sol, ainsi que les couleurs officielles de la nomenclature CORINE Land Cover (consultables ici), vous pouvez procéder de la manière suivante :\n\nintitule_poste &lt;- c(\n  \"Tissu urbain continu\", \"Tissu urbain discontinu\",\n  \"Zones industrielles ou commerciales et installations publiques\",\n  \"Réseaux routier et ferroviaire et espaces associés\", \n  \"Aéroports\",\"Extraction de matériaux\", \n  \"Equipements sportifs et de loisirs\", \n  \"Terres arables hors périmètres d'irrigation\", \"Vignobles\", \n  \"Vergers et petits fruits\", \n  \"Prairies et autres surfaces toujours en herbe à usage agricole\", \n  \"Systèmes culturaux et parcellaires complexes\", \n  \"Surfaces essentiellement agricoles (interrompues par espaces nat.)\", \n  \"Forêts de feuillus\", \"Forêts de conifères\", \"Forêts mélangées\",\n  \"Pelouses et pâturages naturels\", \n  \"Landes et broussailles\", \"Végétation sclérophylle\", \n  \"Forêt et végétation arbustive en mutation\", \n  \"Cours et voies d'eau\", \"Plans d'eau\"\n)\ncouleur_off &lt;- c(\"#E6004D\", \"#FF0000\", \"#CC4DF2\", \"#CC0000\", \"#E6CCE6\", \"#A600CC\", \n                 \"#FFE6FF\", \"#FFFFA8\", \"#E68000\", \"#F2A64D\", \"#E6E64D\", \"#FFE64D\", \n                 \"#E6CC4D\", \"#80FF00\", \"#00A600\", \"#4DFF00\", \"#CCF24D\", \"#A6FF80\", \n                 \"#A6E64D\", \"#A6F200\", \"#00CCF2\", \"#80F2E6\")\nplot(clc, \n     type = \"classes\", \n     levels = intitule_poste,\n     col = couleur_off, \n     plg = list(cex = 0.7),\n     mar = c(3.1, 1.1, 1.1, 10)\n     )",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Affichage</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html",
    "href": "12_modif_zone_terra.html",
    "title": "12  Modifications de la zone d’étude",
    "section": "",
    "text": "12.1 Projections\nPour modifier le système de projection d’un raster, nous pouvons utiliser la fonction project(). Il est alors nécessaire de fournir un modèle et d’indiquer la méthode d’estimation des nouvelles valeurs des cellules.\nLe modèle est un nouveau raster sur lequel aligner/projeter les données. Pour construire un modèle, nous utilisons dans un premier temps la fonction project(x, crs). Cette fonction va produire un raster avec une résolution choisie automatiquement. Nous utilisons ensuite la fonction res() (ou dim()) pour ajuster la résolution de ce raster modèle (voir ?project). La fonction project() peut ensuite être réutiliser pour projeter les valeurs dans le modèle, en précisant la méthode d’estimation à utiliser.\nQuatre méthodes d’estimation sont disponibles :\nPour sauvegarder les rasters reprojetés :\nwriteRaster(elev, filename = \"data/elev.tif\")\nwriteRaster(clc, filename = \"data/clc.tif\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#sec-proj",
    "href": "12_modif_zone_terra.html#sec-proj",
    "title": "12  Modifications de la zone d’étude",
    "section": "",
    "text": "near : plus proche voisin. Méthode rapide et par défaut pour les données qualitatives;\n\nbilinear : interpolation bilinéaire. Méthode par défaut pour les données quantitatives;\n\ncubic : interpolation cubique;\n\ncubicspline : interpolation cubique spline.\n\nlibrary(terra)\n\n#&gt; terra 1.7.71\n\nelev_raw &lt;- rast(\"data/elevation.tif\") \nclc_raw &lt;- rast(\"data/clc_2018.tif\")\n\n# Création d'un modele de raster en 2154\nmodel_proj &lt;- project(x = elev_raw, y = \"EPSG:2154\")\n\n# Ajustement de la résolution du modèle (100 m)\nres(model_proj) &lt;- 100\n\n# Projection dans le modèle\nelev &lt;- project(x = elev_raw, y = model_proj, method = \"bilinear\")\nclc &lt;- project(x = clc_raw, y = model_proj, method = \"near\")\n\nplot(elev, main = \"Altitudes - RGF93 v1 / Lambert-93\" )\nplot(clc, type = \"classes\",  main = \"CLC - RGF93 v1 / Lambert-93\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#sec-crop",
    "href": "12_modif_zone_terra.html#sec-crop",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.2 Crop",
    "text": "12.2 Crop\nLe découpage d’un raster en fonction de l’étendue d’un autre objet, SpatVector ou SpatRaster, est réalisable avec la fonction crop().\n\n\n\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nImport de données vectorielles (découpages communaux) avec la fonction vect du package terra. Ces données seront stockées dans un objet SpatVector.\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer=\"communes\")\n\nExtraction des limites communales de Cahors (code INSEE = 46042).\n\ncahors &lt;- subset(commune, commune$INSEE_COM == \"46042\") \n\nPour utiliser la fonction crop(), les deux couches de données doivent être dans la même projection.\n\ncrop_cahors &lt;- crop(elev, cahors)\n\nplot(crop_cahors)\nplot(cahors, add = TRUE)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#mask",
    "href": "12_modif_zone_terra.html#mask",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.3 Mask",
    "text": "12.3 Mask\nPour afficher uniquement les valeurs d’un raster contenu dans un polygone, utilisez la fonction mask().\nCréation d’un masque sur le raster crop_cahors en fonction des limites communales (polygone) de cahors :\n\nmask_cahors &lt;- mask(crop_cahors, cahors)\n\nplot(mask_cahors)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMask vs. Crop\n\n\n\nMasquer un raster (mask) signifie remplacer les valeurs de pixels en dehors d’une zone d’intérêt en NA. Les dimensions du raster ne sont pas modifiées.\nRecadrer un raster (crop) signifie supprimer les lignes et/ou les colonnes qui se trouvent en dehors d’une zone d’intéret. Les dimensions du raster sont modifiées.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#agrégation-désagrégation",
    "href": "12_modif_zone_terra.html#agrégation-désagrégation",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.4 Agrégation & désagrégation",
    "text": "12.4 Agrégation & désagrégation\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nLe ré-échantillonnage d’un raster dans une résolution différente se fait en plusieurs étapes.\n\nAfficher la résolution d’un raster avec la fonction res().\n\n\nres(elev) \n\n#&gt; [1] 100 100\n\n\n\nCréer une grille de même étendue, puis en diminuer la résolution spatiale (plus grosses cellules).\n\n\nelev_lower_model  &lt;- elev\n\n# Tailles des cellules = 1000 mètres\nres(elev_lower_model) &lt;- 1000\n\nelev_lower_model\n\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 33, 31, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 1000, 1000  (x, y)\n#&gt; extent      : 560073.1, 591073.1, 6357644, 6390644  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154)\n\n\n\nLa fonction resample() permet de ré-échantillonner les valeurs de départ dans la nouvelle résolution spatiale. Plusieurs méthodes de ré-échantillonnage sont disponibles (voir Section 12.1).\n\n\nelev_lower &lt;- resample(x = elev,\n                       y = elev_lower_model, \n                       method = \"bilinear\") \n\nplot(elev_lower, \n     main = \"cellsize = 1000m - ré-échantillonnage bilinéaire\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#fusion-de-raster",
    "href": "12_modif_zone_terra.html#fusion-de-raster",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.5 Fusion de raster",
    "text": "12.5 Fusion de raster\nIl est possible de fusionner plusieurs objets SpatRaster en un seul avec merge() ou mosaic().\n\n\n\nSite web ESRI\n\n\nAprès un découpage du raster d’élévation par la limite communale de Cahors (voir Section 12.2), nous réalisons la même chose pour la commune limitrophe de Bellefont-La Rauze.\n\n# Extraction des limites communales de Bellefont-La Rauze\nbellefont &lt;- subset(commune, commune$INSEE_COM == \"46156\") \n\n# Découpage du raster d'élévation en fonction des limites de Bellefont-La Rauze\ncrop_bellefont &lt;- crop(elev, bellefont)\n\nLes rasters d’élévation crop_cahors et crop_bellefont se chevauchent spatialement :\nplot(crop_cahors, main = \"Crop Cahors\")\nplot(cahors, add = TRUE)\nplot(bellefont, add = TRUE)\nplot(crop_bellefont, main = \"Crop Bellefont-La Rauze\")\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nLa différence entre les fonctions merge() ou mosaic() concerne les valeurs des cellules qui se superposent. La fonction mosaic() calcule la valeur moyenne tandis que merge() conserve la valeur du premier objet SpatRaster appelé dans la fonction.\n\n# Dans cet exemple, merge() et mosaic() donnent le même résultat\nmerge_raster &lt;- merge(crop_cahors, crop_bellefont)\nmosaic_raster &lt;- mosaic(crop_cahors, crop_bellefont)\n\nplot(merge_raster)\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#segregate",
    "href": "12_modif_zone_terra.html#segregate",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.6 Segregate",
    "text": "12.6 Segregate\nLa fonction segregate()permet de décomposer un raster par valeur (ou modalité) en différentes couches matricielles.\n\nclc_by_class &lt;- segregate(clc, keep = TRUE, other = NA)\n\nplot(clc_by_class)\n\n\n\n\n\n\n\n\n\n\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html",
    "href": "13_algebre_spatial_terra.html",
    "title": "13  Algèbre spatial",
    "section": "",
    "text": "13.1 Opérations locales\nLes opérations locales concernent les calculs réalisés indépendamment sur une cellule, à partir d’une ou plusieurs couches (matrices).",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatial</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-locales",
    "href": "13_algebre_spatial_terra.html#opérations-locales",
    "title": "13  Algèbre spatial",
    "section": "",
    "text": "Mennis (2015)\n\n\n\n\n13.1.1 Remplacement de valeur\n\n# Remplace les valeurs -9999 par NA\nelev[elev[[1]]== -9999] &lt;- NA\n\n# Remplace les valeurs &lt; 1500 par NA\nelev[elev &lt; 1500]  &lt;- NA\n\n# Remplace les valeurs NA par 0\nelev[is.na(elev )] &lt;- 0\n\n\n\n13.1.2 Opération sur chaque cellule\n\n# Ajout de 1000 à la valeur de chaque cellule\nelev_1000 &lt;-  elev + 1000\n\n# Suppression de l'altitude médiane à la valeur de chaque cellule\nelev_med &lt;-  elev - global(x = elev, fun = median, na.rm = TRUE)[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n13.1.3 Reclassification\nLa reclassification des valeurs d’un raster peut aussi bien être utilisée pour discrétiser des données quantitatives que pour catégoriser des modalités qualitatives.\nCela permet par exemple de répartir les 44 postes de la nomenclature CLC selon les 5 grands types d’occupation du territoire : territoires artificialisés, agricoles, forêts et milieux semi-naturels, zones humides et surfaces en eau. Pour cela, il est d’abord nécessaire de construire une table de correspondance avec la fonction matrix().\n\nreclassif &lt;- matrix(c(100, 199, 1,\n                      200, 299, 2,\n                      300, 399, 3,\n                      400, 499, 4,\n                      500, 599, 5),\n                    ncol = 3, \n                    byrow = TRUE)\nreclassif\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]  100  199    1\n#&gt; [2,]  200  299    2\n#&gt; [3,]  300  399    3\n#&gt; [4,]  400  499    4\n#&gt; [5,]  500  599    5\n\n\nLes valeurs comprises entre 100 et 199 seront remplacées par la valeur 1. Les valeurs comprises entre 200 et 299 seront remplacées par la valeur 2. Les valeurs comprises entre 300 et 399 seront remplacées par la valeur 3. …\nLa fonction classify() permet de réaliser la reclassification.\n\nclc_5 &lt;- classify(clc, rcl = reclassif)\n\nplot(clc_5, type = \"classes\")\n\n\n\n\n\n\n\n\nAffichage avec les intitulés et couleurs officiels des différentes catégories.\n\nplot(clc_5,\n     type = \"classes\",\n     levels = c(\"Territoires artificialisés\",\n                \"Territoires agricoles\",\n                \"Forêts et milieux semi-naturels\",\n                \"Surfaces en eau\"),\n     col = c(\"#E6004D\", \"#FFFFA8\", \"#80FF00\", \"#00CCF2\"), \n     plg = list(cex = 0.7))\n\n\n\n\n\n\n\n\n\n\n13.1.4 Opération sur plusieurs couches (ex: NDVI)\nIl est possible de calculer une valeur de cellule à partir de différentes valeurs stockées dans plusieurs couches d’un objet SpatRaster.\nL’exemple le plus courant est sans doute le calcul de l’indice de végétation normalisé (NDVI). Pour chaque cellule, on calcule une valeur à partir de deux couches de données matricielles d’une image satellite multispectrale.\n\n# Import d'une image satellite multispectrale\nSentinel2a &lt;- rast(\"data/Sentinel2A.tif\")\n\nSentinel2a\n\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 1242, 1061, 2  (nrow, ncol, nlyr)\n#&gt; resolution  : 9.997187, 9.997187  (x, y)\n#&gt; extent      : 570465.7, 581072.7, 6368052, 6380468  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \n#&gt; source      : Sentinel2A.tif \n#&gt; names       : T31TCK_20211012T105011_B04_10m, T31TCK_20211012T105011_B08_10m \n#&gt; min values  :                              1,                              4 \n#&gt; max values  :                          16112,                          11273\n\n\nCette image satellite multispectrale (résolution de 10m) datée du 12/10/2021, a été produite par le satellite Sentinel-2 et a été récupéré sur la plateforme Copernicus Open Access Hub. Une extraction des bandes spectrales Rouge et proche infrarouge, centrée sur le département du Lot a ensuite été réalisée.\n\nplot(Sentinel2a)\n\n\n\n\n\n\n\n\nPour alléger le code, on assigne les couches matricielles dans deux objets SpatRaster différents.\n\n# Bande spectrale rouge\nB04_Red &lt;- Sentinel2a[[1]]\n\n# Bande spectrale proche infrarouge\nB08_NIR &lt;-Sentinel2a[[2]]\n\nÀ partir de ces deux rasters, nous pouvons calculer l’indice de végétation normalisé :\n\\[{NDVI}=\\frac{\\mathrm{NIR} - \\mathrm{Red}} {\\mathrm{NIR} + \\mathrm{Red}}\\]\n\nraster_NDVI &lt;- (B08_NIR - B04_Red ) / (B08_NIR + B04_Red )\nplot(raster_NDVI)\n\n\n\n\n\n\n\n\nPlus les valeurs sont importantes (proche de 1), plus la végétation est dense.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatial</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-focales",
    "href": "13_algebre_spatial_terra.html#opérations-focales",
    "title": "13  Algèbre spatial",
    "section": "13.2 Opérations focales",
    "text": "13.2 Opérations focales\n\n\n\nMennis (2015)\n\n\nL’analyse focale considère une cellule plus ses voisins directs de manière contiguë et symétrique (opérations de voisinage). Le plus souvent, la valeur de la cellule de sortie est le résultat d’un bloc de cellules d’entrée 3 x 3 (nombre impair).\nLa première étape consiste à construire une matrice qui détermine le bloc de cellules qui sera pris en compte autour de chaque cellule.\n\n# Matrice 9 x 9, où chaque cellule présente la même pondération (1)\nmon_focal &lt;- matrix(1, nrow = 9, ncol = 9)\nmon_focal\n\n#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n#&gt;  [1,]    1    1    1    1    1    1    1    1    1\n#&gt;  [2,]    1    1    1    1    1    1    1    1    1\n#&gt;  [3,]    1    1    1    1    1    1    1    1    1\n#&gt;  [4,]    1    1    1    1    1    1    1    1    1\n#&gt;  [5,]    1    1    1    1    1    1    1    1    1\n#&gt;  [6,]    1    1    1    1    1    1    1    1    1\n#&gt;  [7,]    1    1    1    1    1    1    1    1    1\n#&gt;  [8,]    1    1    1    1    1    1    1    1    1\n#&gt;  [9,]    1    1    1    1    1    1    1    1    1\n\n\nLa fonction focal() permet ensuite de réaliser l’analyse souhaitée. Par exemple : le calcul de la moyenne des valeurs dans une fenêtre spatiale determinée, pour chaque cellule du raster.\n\nelev_focal_mean &lt;- focal(elev, w = mon_focal, fun = mean)\n\nplot(elev, main = \"raster de départ\")\nplot(elev_focal_mean, main=\"résultat : focal 9 x 9, pondération uniforme\")\n\n\n\n\n\n\n\n\n\n\n\n13.2.1 Opération focales pour rasters d’élévation\nLa fonction terrain() permet de réaliser des analyses focales spécifiques au rasters d’élévation. Six opérations sont disponibles :\n\nslope = calcul de la pente ou degré d’inclinaison de la surface;\naspect = calcul de l’orientation de la pente;\nroughness = calcul de la variabilité ou l’irrégularité de l’élévation;\nTPI = calcul de l’indice des positions topographiques;\nTRI = calcul de l’indice de la variabilité de l’élévation;\nflowdir = calcul du sens d’écoulement de l’eau.\n\nExemples avec le calcul des pentes (slope), c’est à dire leur inclinaison en degrés.\n\nslope &lt;- terrain(elev, \"slope\",\n                 neighbors = 8, # 8 (ou 4) cellules autour pris en compte\n                 unit = \"degrees\") # Unité en sortie\n\nplot(slope)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatial</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-globales",
    "href": "13_algebre_spatial_terra.html#opérations-globales",
    "title": "13  Algèbre spatial",
    "section": "13.3 Opérations globales",
    "text": "13.3 Opérations globales\n\n\n\ngisgeography.com\n\n\nLes opérations globales permettent de résumer les valeurs matricielles d’une ou plusieurs matrices.\n\n# Valeur moyenne\nglobal(elev, fun = \"mean\", na.rm = TRUE)\n\n#&gt;              mean\n#&gt; altitude 251.3601\n\n# Écart-type\nglobal(elev, fun = \"sd\", na.rm = TRUE)\n\n#&gt;                sd\n#&gt; altitude 54.58627\n\n# Fréquence\nfreq(clc_5)\n\n#&gt;   layer value count\n#&gt; 1     1     1  3775\n#&gt; 2     1     2 38118\n#&gt; 3     1     3 56331\n#&gt; 4     1     5   928\n\n\nReprésentations statistiques qui résument les informations matricielles.\n\n# Histogramme\nhist(elev)\n\n\n\n\n\n\n\n# Densité\ndensity(elev)\n\n\n\n\n\n\n\n# boxplot\nboxplot(elev)\n\n#&gt; Warning: [boxplot] taking a sample of 1e+05 cells",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatial</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-zonales",
    "href": "13_algebre_spatial_terra.html#opérations-zonales",
    "title": "13  Algèbre spatial",
    "section": "13.4 Opérations zonales",
    "text": "13.4 Opérations zonales\n\n\n\nMennis (2015)\n\n\nLes opérations zonales permettent de résumer les valeurs matricielles de certaines zones (groupe de cellules contiguë dans l’espace ou en valeur).\n\n13.4.1 Opération zonale à partir d’une couche vectorielle\nLa fonction extract() permet d’extraire et de manipuler les valeurs des cellules qui intersectent des données vectorielles.\nExemple à partir des limites communales :\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\n\n# Moyenne d'élévation pour chaque polygone (commune) \nelev_by_com &lt;-  extract(elev, commune, fun = mean, na.rm = FALSE)\nhead(elev_by_com, n = 3)\n\n#&gt;   ID altitude\n#&gt; 1  1      NaN\n#&gt; 2  2      NaN\n#&gt; 3  3      NaN\n\n# Suppression des valeurs NaN\nelev_by_com &lt;- elev_by_com[!is.nan(elev_by_com$altitude),]\n\n# Remplacement des identifiants uniques par le nom des communes\nelev_by_com$ID &lt;- commune[elev_by_com$ID]$NOM_COM\nhead(elev_by_com, n = 6)\n\n#&gt;                    ID altitude\n#&gt; 7            Arcambal 213.0009\n#&gt; 10             Aujols 216.7961\n#&gt; 23 Belmont-Sainte-Foi 302.4436\n#&gt; 29         Boissières 252.0305\n#&gt; 39             Cahors 205.1988\n#&gt; 41            Caillac 145.9868\n\n\n\n\n13.4.2 Opération zonale à partir d’un raster\nLes opérations zonales peuvent être réalisées par zone délimitée par les valeurs catégorielles d’un second raster avec la fonction zonal(). Pour cela, les deux rasters doivent avoir exactement le même étendue et la même résolution.\n\n# Élévation moyenne pour chaque zone de clc\nzonal(elev, clc_5, \"mean\", na.rm = TRUE)\n\n#&gt;   clc altitude\n#&gt; 1   1 209.7177\n#&gt; 2   2 259.3624\n#&gt; 3   3 249.4070\n#&gt; 4   5 115.8435\n\n\n\n\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar fields. https://slideplayer.com/slide/5822638/.\n\n\nMennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html.\n\n\nTomlin, C. D. (1990). Geographic information systems and cartographic modeling. Prentice Hall.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatial</span>"
    ]
  },
  {
    "objectID": "14_transformation_terra.html",
    "href": "14_transformation_terra.html",
    "title": "14  Conversions",
    "section": "",
    "text": "14.1 Rasterisation\nTransformer des polygones en format raster avec la fonction rasterize().\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\nelev &lt;- rast(\"data/elev.tif\") \n\nraster_commune &lt;- rasterize(x = commune, y = elev , field = \"NOM_COM\")\nplot(raster_commune)\nTransformer des points en format raster :\n# Rasterisation des centroïdes des communes\nraster_com_centroide &lt;- rasterize(x = centroids(commune), \n                                  y = elev, fun = sum)\nplot(raster_com_centroide)\nTransformer des lignes format raster :\n# Rasterisation des limites communales\nraster_com_line &lt;- rasterize(x = as.lines(commune), y = elev, fun=sum)\nplot(raster_com_line)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conversions</span>"
    ]
  },
  {
    "objectID": "14_transformation_terra.html#vectorisation",
    "href": "14_transformation_terra.html#vectorisation",
    "title": "14  Conversions",
    "section": "14.2 Vectorisation",
    "text": "14.2 Vectorisation\nTransformer un raster en polygones ou en points avec les fonctions as.polygons() et as.points(). Les objets créés sont dans le format SpatVector de terra.\nIl est ensuite possible de les transformer en objets sf avec la fonction st_as_sf().\n\nlibrary(terra)\nlibrary(sf)\nclc &lt;- rast(x = \"data/clc.tif\")\n\n# Reclassifions le raster CLC\nreclassif &lt;- matrix(c(100, 199, 1,\n                      200, 299, 2,\n                      300, 399, 3,\n                      400, 499, 4,\n                      500, 599, 5),\n                    ncol = 3, \n                    byrow = TRUE)\nclc &lt;- classify(clc, rcl = reclassif)\n\n# Changeons d'abord la résolution du raster CLC\nclc_lower_model &lt;- clc\nres(clc_lower_model) &lt;- 1000\n\nclc_lower &lt;- resample(x = clc, y = clc_lower_model, method = \"near\") \n\n# Transformation en polygones\nclc_poly &lt;- as.polygons(clc_lower)\nclc_poly &lt;- st_as_sf(clc_poly)\n\n# Affichage \nclc_poly$clc &lt;- as.factor(clc_poly$clc)\nplot(clc_poly[\"clc\"])\n\n\n\n\n\n\n\n\nTransformer un raster en points vectoriels avec la fonction as.points():\n\nclc_point &lt;- as.points(clc_lower)\nclc_point &lt;- st_as_sf(clc_point)\nclc_point$clc &lt;- as.factor(clc_point$clc)\nplot(clc_point[\"clc\"], pch = 20, cex = 2)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conversions</span>"
    ]
  },
  {
    "objectID": "15_OSM.html",
    "href": "15_OSM.html",
    "title": "15  OpenStreetMap",
    "section": "",
    "text": "OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le monde entier.\nConditions d’utilisation\n\nOpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…)\n\nContributeurs\n\n(…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…)\n\n\n\n\n\n\n\nA propos d’OpenStreetMap",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>OpenStreetMap</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html",
    "href": "16_OSM_interactif.html",
    "title": "16  Cartes interactives",
    "section": "",
    "text": "16.1 leaflet\nleaflet utilise la libraire javascript Leaflet (Agafonkin, 2015) pour créer des cartes interactives.\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.11.1, GDAL 3.6.2, PROJ 9.1.1; sf_use_s2() is TRUE\n\nlibrary(leaflet)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, cahors)\n\n# transformation du système de coordonnées en WGS84\ncahors &lt;- st_transform(cahors, 4326)\nrestaurant_cahors &lt;- st_transform(restaurant_cahors, 4326)\n\n# Création de la carte interactive\nm &lt;- leaflet(cahors) %&gt;%\n  addTiles() %&gt;%\n  addPolygons() %&gt;%\n  addMarkers(data = restaurant_cahors)\nm",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html#leaflet",
    "href": "16_OSM_interactif.html#leaflet",
    "title": "16  Cartes interactives",
    "section": "",
    "text": "Site web de leaflet\n\n\n\nLeaflet for R",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html#mapview",
    "href": "16_OSM_interactif.html#mapview",
    "title": "16  Cartes interactives",
    "section": "16.2 mapview",
    "text": "16.2 mapview\n mapview s’appuie sur leaflet pour créer des carte interactive, sont utilisation basique est plus simple bien que sa documentation ne soit pas vraiment facile à aborder.\n\nlibrary(mapview)\nmapview(cahors) + mapview(restaurant_cahors)\n\n\n\n\n\n\n\n\n\n\n\nSite web de mapview mapview\n\n\n\n\n\n\n\nAgafonkin, V. (2015). JavaScript library for mobile-friendly interactive maps. https://github.com/Leaflet/Leaflet\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2023). mapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview\n\n\nCheng, J., Schloerke, B., Karambelkar, B. et Xie, Y. (2023). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://CRAN.R-project.org/package=leaflet",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "17_OSM_static.html",
    "href": "17_OSM_static.html",
    "title": "17  Import de fonds de carte",
    "section": "",
    "text": "Le package maptiles (Giraud, 2023) permet de télécharger et d’afficher des fonds de cartes raster. La fonction get_tiles() permet de télécharger des fonds de cartes OSM au format SpatRaster du package terra.\nDans cette exemple nous utilisons le package mapsf pour afficher la carte.\nLes rendus sont meilleurs si les données en entrée utilisent le même système de coordonnées que les tuiles (EPSG:3857).\n\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapsf)\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com, 3857)\n\n# Récupération d'un fond de carte OSM\nosm_tiles &lt;- get_tiles(x = com, zoom = 9, crop = TRUE)\n\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm_tiles)\nmf_map(com, border = \"grey20\", col = NA, lwd = .7, add = TRUE)\nmf_credits(get_credit(\"OpenStreetMap\"), bg = \"#ffffff80\")\n\n\n\n\n\n\n\n\nDe nombreux styles de tuiles sont disponibles avec le package. En voici quelque uns:\n\nCertains styles ne contiennent que des labels et peuvent être utilisés en complément de données vectorielles:\n\n# Récupération d'un fond de carte OSM des labels\nmf_theme(mar = c(0,0,0,0))\nosm_labels &lt;- get_tiles(x = com, provider = \"CartoDB.PositronOnlyLabels\")\nmf_map(com, col = 'ivory', border = 'ivory3')\nmf_raster(osm_labels, add = T)\nmf_credits(get_credit(\"CartoDB.PositronOnlyLabels\"), bg = \"#ffffff80\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPour certains styles, ceux fournis par Stadia ou Thunderforest par exemple, vous aurez besoin d’une clef d’API. Vous devez vous inscrire sur le site Web de ces fournisseurs pour obtenir une clef.\n\n\n\n\n\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Import de fonds de carte</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html",
    "href": "18_OSM_data.html",
    "title": "18  Import de données",
    "section": "",
    "text": "18.1 osmdata\nLe package osmdata (Mark Padgham et al., 2017) permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo.\nlibrary(sf)\nlibrary(osmdata)\n\n#&gt; Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n\n# Définition d'une bounding box\nq &lt;- opq(bbox = st_bbox(st_transform(cahors, 4326)))\n\n# Extraction des restaurants\nreq &lt;- add_osm_feature(opq = q, key = 'amenity', value = \"restaurant\")\nres &lt;- osmdata_sf(req)\n\n# Reduction du resultats :\n# les points composant les polygones sont supprimés\nres &lt;- unique_osmdata(res)\nLe résultat contient une couche de points et une couche de polygones. Cela signifie que certains restaurants (la très grande majorité) sont enregistrés sous forme de points dans OSM et d’autres sous forme de polygones. Pour obtenir une couche de points cohérente nous pouvons utiliser les centroides des polygones.\nresto_point &lt;- res$osm_points\n\n# extraire les centroides des polygones\nresto_poly_point &lt;- st_centroid(res$osm_polygons)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\n# identifier les champs en commun\nchps &lt;- intersect(names(resto_point), names(resto_poly_point))\n\n# Union des deux couches\nresto &lt;- rbind(resto_point[, chps], resto_poly_point[, chps])\nAffichage des résultats\nlibrary(mapview)\nmapview(cahors) + mapview(resto)",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html#osmdata",
    "href": "18_OSM_data.html#osmdata",
    "title": "18  Import de données",
    "section": "",
    "text": "Site web d’osmdata\n\n\n\nosmdata",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html#osmextract",
    "href": "18_OSM_data.html#osmextract",
    "title": "18  Import de données",
    "section": "18.2 osmextract",
    "text": "18.2 osmextract\n Le package osmextract (Gilardi et Lovelace, 2023) permet d’extraire des données depuis une base de données OSM directement. Ce package permet de travailler en local sur des volumes de données très importants et ainsi d’éviter de surcharger un serveur Overpass turbo.\nLa fonction oe_get() permet de télécharger un extrait de la base de données OSM sur une zone particulière et de sélectionner un type d’objet à importer.\nL’argument place correspond au nom du fichier *.pbf accessible sur le site Geofabrik. L’argument extra_tag permet de sélectionner les objets de la base OSM correspondant à une clef particulière (se référer à la documentation d’OSM pour choisir les clefs).\nNous nous intéressons ici à l’ensemble des équipements (clef amenity) enregistrés dans la base OSM sous forme de points en Andorre.\n\nlibrary(osmextract)\n\n#&gt; Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright.\n#&gt; Check the package website, https://docs.ropensci.org/osmextract/, for more details.\n\nosm_pt &lt;- oe_get(place = \"Andorra\",      \n                 layer = \"points\", \n                 extra_tags = \"amenity\", \n                 quiet = TRUE)\n\nDes équipements de nature très variés sont saisis dans OSM:\n\nunique(osm_pt$amenity)\n\n#&gt;  [1] NA                      \"fuel\"                  \"arts_centre\"          \n#&gt;  [4] \"restaurant\"            \"parking\"               \"theatre\"              \n#&gt;  [7] \"fast_food\"             \"bar\"                   \"hospital\"             \n#&gt; [10] \"atm\"                   \"school\"                \"pharmacy\"             \n#&gt; [13] \"ski_rental\"            \"toilets\"               \"bank\"                 \n#&gt; [16] \"veterinary\"            \"post_box\"              \"pub\"                  \n#&gt; [19] \"telephone\"             \"cafe\"                  \"public_building\"      \n#&gt; [22] \"shelter\"               \"car_wash\"              \"fountain\"             \n#&gt; [25] \"parking_entrance\"      \"post_office\"           \"bench\"                \n#&gt; [28] \"place_of_worship\"      \"drinking_water\"        \"recycling\"            \n#&gt; [31] \"cinema\"                \"library\"               \"nightclub\"            \n#&gt; [34] \"police\"                \"kindergarten\"          \"mini_storage\"         \n#&gt; [37] \"bbq\"                   \"courthouse\"            \"car_rental\"           \n#&gt; [40] \"dojo\"                  \"waste_basket\"          \"water_point\"          \n#&gt; [43] \"dentist\"               \"doctors\"               \"townhall\"             \n#&gt; [46] \"bus_station\"           \"bicycle_parking\"       \"sanitary_dump_station\"\n#&gt; [49] \"charging_station\"      \"community_centre\"      \"waste_disposal\"       \n#&gt; [52] \"watering_place\"        \"internet_cafe\"         \"motorcycle_parking\"   \n#&gt; [55] \"photo_booth\"           \"locker\"                \"shower\"               \n#&gt; [58] \"events_venue\"          \"public_bookcase\"       \"animal_shelter\"       \n#&gt; [61] \"biergarten\"            \"childcare\"             \"clinic\"               \n#&gt; [64] \"lavoir\"                \"vending_machine\"\n\n\nNous allons maintenant sélectionner les bars, cafés, pubs et restaurants et les visualiser sur une carte interactive.\n\npoi &lt;- c(\"bar\", \"cafe\", \"pub\", \"restaurant\")\nosm_pt &lt;- osm_pt[osm_pt$amenity %in% poi, ]\n\nlibrary(leaflet)\n\npal &lt;- colorFactor(palette = c(\"navy\", \"red\", \"darkgreen\", \"gold\"),\n                   domain = poi)\n\nleaflet(osm_pt) |&gt;\n  addProviderTiles(\"OpenStreetMap.HOT\") |&gt;\n  addCircleMarkers(radius = 4,\n                   stroke = FALSE,\n                   color = ~ pal(amenity),\n                   fillOpacity = 1,\n                   popup = osm_pt$name) |&gt;\n  addLegend(pal = pal,\n            values = poi,\n            opacity = 0.7,\n            title = \"OSM amenity\",\n            position = \"bottomright\"\n  ) \n\n\n\n\n\n\n\n\n\n\n\nSite web d’osmextract\n\n\n\nosmextract\n\n\n\n\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017). osmdata. Journal of Open Source Software, 2(14), 305. https://doi.org/10.21105/joss.00305",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "19_OSM_routing.html",
    "href": "19_OSM_routing.html",
    "title": "19  Matrices de temps et itinéraires",
    "section": "",
    "text": "19.1 Calcul d’un itinéraire\nLa fonction osrmRoute() permet de calculer des itinéraires.\nlibrary(sf)\nlibrary(osrm)\nlibrary(maptiles)\n\ncom_raw &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com_raw, 3857)\n\n# Itinéraire entre les centroïdes de Cahors et de Puybrun\ncahors  &lt;- st_centroid(com[com$INSEE_COM == \"46042\", ])\npuybrun &lt;- st_centroid(com[com$INSEE_COM == \"46229\", ])\n\nroute &lt;- osrmRoute(src = cahors,\n                   dst = puybrun)\n\n# Récupération d'un fond de carte OSM\nosm &lt;- get_tiles(st_buffer(route, 2000), crop = TRUE)\n\n# Affichage\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm)\nmf_map(route, col = \"grey10\", lwd = 6, add = T)\nmf_map(route, col = \"grey90\", lwd = 1, add = T)",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Matrices de temps et itinéraires</span>"
    ]
  },
  {
    "objectID": "19_OSM_routing.html#calcul-dune-matrice-de-temps",
    "href": "19_OSM_routing.html#calcul-dune-matrice-de-temps",
    "title": "19  Matrices de temps et itinéraires",
    "section": "19.2 Calcul d’une matrice de temps",
    "text": "19.2 Calcul d’une matrice de temps\nLa fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route.\n\n\n\n\n\n\nGéoréférencement d’adresses ?\n\n\n\nVoir le point Géoréférencement pour le géocodage d’adresse avec R\n\n\nDans cet exemple nous calculons une matrice de temps entre 2 adresses et les restaurants de Cahors à pied.\n\nlibrary(sf)\nlibrary(tidygeocoder)\n\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, com_raw[com_raw$INSEE_COM == \"46042\", ])\n\n# Construction d'un data.frame contenant deux adresses\nadresses &lt;- data.frame(ad = c(\"3 rue Montaudié, Cahors, France\",\n                              \"5 rue Albert Camus, Cahors, France\"))\n\n# Geocodage de 2 adresses à Cahors\nplaces &lt;- geocode(.tbl = adresses,address = ad, quiet = TRUE)\nplaces &lt;- as.data.frame(places)\nrow.names(places) &lt;- c(\"Rue Montaudié\", \"Rue Albert Camus\")\n\n# Calcul de la matrice de distance entre les 2 adresses et les restaurants de Cahors\nmat &lt;- osrmTable(src = places[c(3, 2)],\n                 dst = restaurant_cahors,\n                 osrm.profile = \"foot\")\n\nmat$durations[, 1:5]\n\n#&gt;                     1    2    3    4    5\n#&gt; Rue Montaudié    18.1 21.3 22.2 22.7 14.5\n#&gt; Rue Albert Camus 31.4 63.0 35.4 23.0 32.6\n\n# Quelle adresse possède une meilleurs accessibilité aux restaurants ?\nboxplot(t(mat$durations), cex.axis = .7, horizontal = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nGiraud, T. (2022). osrm: Interface Between R and the OpenStreetMap-Based Routing Service OSRM. Journal of Open Source Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap data. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Matrices de temps et itinéraires</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html",
    "href": "1999_georeferencement.html",
    "title": "20  Géocodage",
    "section": "",
    "text": "20.1 Géocodage d’adresse avec tidygeocoder\nPlusieurs packages permettent de géocoder des adresses.  Le package tidygeocoder (Cambon et al., 2021) permet d’utiliser un grand nombre de services de géocodage en ligne.\nlibrary(tidygeocoder)\naddress_df &lt;- data.frame(\n  address = c(\"10 Emma Goldmanweg, 5032MN Tilburg, Netherlands\", \n              \"19 rue Michel Bakounine, 29600 Morlaix, France\")\n)\n\nplaces &lt;- geocode(.tbl = address_df, address = \"address\", quiet = TRUE)\nplaces\n\n#&gt; # A tibble: 2 × 3\n#&gt;   address                                           lat  long\n#&gt;   &lt;chr&gt;                                           &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  51.5  5.04\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France   48.6 -3.82",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "href": "1999_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "title": "20  Géocodage",
    "section": "20.2 Transformer des données long/lat en objet sf",
    "text": "20.2 Transformer des données long/lat en objet sf\nLa fonction st_as_sf() permet de créer un objet sf à partir d’un data.frame contenant des coordonnées géographiques.\nIci nous utilisons le data.frame places créé précédement :\n\nlibrary(sf)\nplace_sf &lt;- st_as_sf(places, \n                     coords = c(\"long\", \"lat\"), \n                     crs = 'EPSG:4326')\nplace_sf\n\n#&gt; Simple feature collection with 2 features and 1 field\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -3.816434 ymin: 48.59041 xmax: 5.038699 ymax: 51.53649\n#&gt; Geodetic CRS:  WGS 84\n#&gt; # A tibble: 2 × 2\n#&gt;   address                                                     geometry\n#&gt; * &lt;chr&gt;                                                    &lt;POINT [°]&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  (5.038699 51.53649)\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France  (-3.816435 48.59041)\n\n\nPour créer un objet sf de type POINT à partir d’une paire de coordonnées, ici le point de longitude 0.5 et de latitude 45.5 en WGS84 (EPSG:4326), il est nécessaire de créer le data.frame au préalable :\n\nlibrary(sf)\ndf_pt &lt;- data.frame(x = 0.5, y = 45.5)\nmon_point &lt;- st_as_sf(df_pt, coords = c(\"x\", \"y\"), crs = 'EPSG:4326')\nmon_point\n\n#&gt; Simple feature collection with 1 feature and 0 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 0.5 ymin: 45.5 xmax: 0.5 ymax: 45.5\n#&gt; Geodetic CRS:  WGS 84\n#&gt;           geometry\n#&gt; 1 POINT (0.5 45.5)",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "href": "1999_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "title": "20  Géocodage",
    "section": "20.3 Affichage sur un fond OpenStreetMap",
    "text": "20.3 Affichage sur un fond OpenStreetMap\nNous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud, 2023).\n\nlibrary(mapsf)\nlibrary(maptiles)\n\n# Récupération d'un fond de carte OSM\nosm &lt;- get_tiles(x = place_sf, zoom = 7)\n\n# Affichage\nmf_raster(osm)\nmf_map(place_sf, pch = 4, cex = 2, \n       lwd = 2, col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: An R package for geocoding. Journal of Open Source Software, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "19992_digit.html",
    "href": "19992_digit.html",
    "title": "21  Digitalisation",
    "section": "",
    "text": "Le package mapedit (Appelhans et al., 2020) permet de digitaliser des fonds de carte directement dans R. Mais disons le franchement, bien que pouvant se révéler pratique dans certains cas, ce package ne saurait se substituer aux fonctionnalités d’un SIG pour les tâches de digitalisation importantes.\n\n\n\n\n\nAppelhans, T., Russell, K. et Busetto, L. (2020). mapedit: Interactive Editing of Spatial Data in R. https://CRAN.R-project.org/package=mapedit",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Digitalisation</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html",
    "href": "2001_donnees.html",
    "title": "22  Packages de données spatiales",
    "section": "",
    "text": "22.1 À l’échelle mondiale",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-mondiale",
    "href": "2001_donnees.html#à-léchelle-mondiale",
    "title": "22  Packages de données spatiales",
    "section": "",
    "text": "rnaturalearth (Massicotte et South, 2023) : permet de récupérer les données cartographiques Natural Earth.\n\n cshapes (Weidmann et al., 2021) : met à disposition les frontières nationales, de 1886 à aujourd’hui.\n\n osmextract (Gilardi et Lovelace, 2023) : permet d’importer des données OpenStreetMap.\n\n osmdata (Mark Padgham et al., 2017) : pour télécharger et utiliser les données d’OpenStreetMap.\n maptiles (Giraud, 2023) : Ce package télécharge, compose et affiche des tuiles à partir d’un grand nombre de fournisseurs (OpenStreetMap, Stadia, Esri, CARTO ou Thunderforest…).\n\n geonames (Rowlingson, 2019) : permet d’interroger la BD geonames, qui fournit notamment des localisations.\n wbstats (Piburn, 2020) et WDI (Arel-Bundock, 2022) : donnent accès aux données et statistiques de la Banque mondiale.\n\n sen2r (Ranghetti et al., 2020) : permet de télécharger et prétraiter automatiquement les données du satellite Sentinel-2.\n\n MODIStsp (Busetto et Ranghetti, 2016) : permet de trouver, télécharger et traiter des images MODIS.\n geodata (Hijmans et al., 2023) : founit un accès à des données sur le climat, l’altitude, le sol, la présence d’espèces et les limites administratives.\n elevatr (Hollister et al., 2023) : donne accès à des données d’élévation mises à disposition par Amazon Web Services Terrain Tiles, l’Open Topography Global Datasets API et l’USGS Elevation Point Query Service.\n rgee (Aybar, 2023) : permet d’utiliser l’API de Google Earth Engine, catalogue de données publiques et infrastructure de calcul pour les images satellites.\n\n nasapower (Sparks, 2018) : API client NASA (prévision des ressources énergétiques mondiales, météorologie, énergie solaire de surface et climatologie).\n geoknife (Read et al., 2015) : permet de traiter (en ligne) des données matricielles volumineuses issuent du Geo Data Portal de l’U.S. Geological Survey.\n  rdhs (Watson et al., 2019) : API client et gestions de données de l’enquête démographique et de santé (DHS).",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-européenne",
    "href": "2001_donnees.html#à-léchelle-européenne",
    "title": "22  Packages de données spatiales",
    "section": "22.2 À l’échelle européenne",
    "text": "22.2 À l’échelle européenne\n\n giscoR (Hernangómez, 2023a) : permet de télécharger des données cartographiques mondiales et européennes de la BD GISCO d’Eurostat (système d’information géographique de la Commission).\n eurostat (Lahti et al., 2017) : permet de télécharger des données de la BD Eurostat.",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-national",
    "href": "2001_donnees.html#à-léchelle-national",
    "title": "22  Packages de données spatiales",
    "section": "22.3 À l’échelle national",
    "text": "22.3 À l’échelle national\n\nBrésil\n\n geobr (Pereira et Goncalves, 2023) : fournit un accès facile aux séries de données spatiales officielles du Brésil pour différentes années et découpage administratifs.\n\nChili\n\n chilemapas (Vargas, 2022) : donne accès aux divisions politiques et administratives du Chili.\n\nEspagne\n\n mapSpain (Hernangómez, 2023b) : propose les limites administratives de l’Espagne à plusieurs niveaux (Communautés autonomes, Provinces, Municipalités), ainsi que des tuiles.\n\nÉtats-Unis\n\n  tidycensus (Walker et Herman, 2023) : permet de charger des données et géométries du recensement américain en format sf et tidyverse\n tigris (Walker, 2023) : donne accès aux éléments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l’eau.\n  FedData (Bocinsky, 2023) : automatise le téléchargement de données géospatiales disponibles à partir de plusieurs sources de données fédérées.\n acs (Glenn, 2019) : permet de télécharger et manipuler les données de l’American Community Survey et les données décennales du recensement des États-Unis.\n censusapi (Recht, 2022) : wrapper pour les API du Census Bureau des États-Unis.\n idbr (Walker, 2021) : interface avec l’API de la base de données internationale du US Census Bureau.\n\n ipumsr (Greg Freedman Ellis et al., 2023) : Permet d’importer des données de recensement, d’enquête et géographiques fournies par l’IPUMS.\n totalcensus (Li, 2021) : permet d’extraire les données du recensement décennal et de l’American Community Survey au niveaux des block, block group et tract.\n\nFinland\n\n mapsFinland (Haukka, 2023) : donne un accès à des cartes et données concernant la Finland.\n\nFrance\n\n happign (Carteron, 2023) : accès à certaines données de l’IGN.\n insee (Leclerc, 2022) : pour télécharger facilement les données de la base BDM (Banque de Données Macroéconomiques) de l’INSEE.\n\nPologne\n\n rgugik (Dyba et Nowosad, 2021) : permet l’acquisition automatique de données ouvertes à partir des ressources du Bureau central polonais de la géodésie et de la cartographie (Główny Urząd Geodezji i Kartografii ).\n\n\nUruguay\n\n geouy (Detomasi, 2023) : permet le chargement d’informations géographiques sur l’Uruguay.\n\n…\n\n\n\n\n\nArel-Bundock, V. (2022). WDI: World Development Indicators and Other World Bank Data. https://CRAN.R-project.org/package=WDI\n\n\nAybar, C. (2023). rgee: R Bindings for Calling the ’Earth Engine’ API. https://CRAN.R-project.org/package=rgee\n\n\nBocinsky, R. K. (2023). FedData: Functions to Automate Downloading Geospatial Data Available from Several Federated Data Sources. https://CRAN.R-project.org/package=FedData\n\n\nBusetto, L. et Ranghetti, L. (2016). MODIStsp: an R package for preprocessing of MODIS Land Products time series. Computers & Geosciences, 97, 40‑48. https://doi.org/10.1016/j.cageo.2016.08.020\n\n\nCarteron, P. (2023). happign: R Interface to ’IGN’ Web Services. https://CRAN.R-project.org/package=happign\n\n\nDetomasi, R. (2023). geouy: Geographic Information of Uruguay. https://github.com/RichDeto/geouy\n\n\nDyba, K. et Nowosad, J. (2021). rgugik: Search and Retrieve Spatial Data from the Polish Head Office of Geodesy and Cartography in R. Journal of Open Source Software, 6(59), 2948. https://doi.org/10.21105/joss.02948\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import Open Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles\n\n\nGlenn, E. H. (2019). acs: Download, Manipulate, and Present American Community Survey and Decennial Data from the US Census. https://CRAN.R-project.org/package=acs\n\n\nGreg Freedman Ellis, Derek Burk et Finn Roberts. (2023). ipumsr: An R Interface for Downloading, Reading, and Handling IPUMS Data. https://CRAN.R-project.org/package=ipumsr\n\n\nHaukka, J. (2023). mapsFinland: Maps of Finland. https://CRAN.R-project.org/package=mapsFinland\n\n\nHernangómez, D. (2023a). giscoR: Download Map Data from GISCO API - Eurostat (version 0.4.0). https://doi.org/10.5281/zenodo.4317946\n\n\nHernangómez, D. (2023b). mapSpain: Administrative Boundaries of Spain (version 0.8.0). https://doi.org/10.5281/zenodo.5366622\n\n\nHijmans, R. J., Barbosa, M., Ghosh, A. et Mandel, A. (2023). geodata: Download Geographic Data. https://CRAN.R-project.org/package=geodata\n\n\nHollister, J., Shah, T., Nowosad, J., Robitaille, A. L., Beck, M. W. et Johnson, M. (2023). elevatr: Access Elevation Data from Various APIs. https://doi.org/10.5281/zenodo.8335450\n\n\nLahti, L., Huovari, J., Kainu, M. et Biecek, P. (2017). Retrieval and Analysis of Eurostat Open Data with the eurostat Package. The R Journal, 9(1), 385‑392. https://doi.org/10.32614/RJ-2017-019\n\n\nLeclerc, H. (2022). insee: Tools to Easily Download Data from INSEE BDM Database. https://CRAN.R-project.org/package=insee\n\n\nLi, G. (2021). totalcensus: Extract Decennial Census and American Community Survey Data. https://CRAN.R-project.org/package=totalcensus\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017). osmdata. Journal of Open Source Software, 2(14), 305. https://doi.org/10.21105/joss.00305\n\n\nMassicotte, P. et South, A. (2023). rnaturalearth: World Map Data from Natural Earth. https://CRAN.R-project.org/package=rnaturalearth\n\n\nPereira, R. H. M. et Goncalves, C. N. (2023). geobr: Download Official Spatial Data Sets of Brazil. https://CRAN.R-project.org/package=geobr\n\n\nPiburn, J. (2020). wbstats: Programmatic Access to the World Bank API. Oak Ridge National Laboratory. https://doi.org/10.11578/dc.20171025.1827\n\n\nRanghetti, L., Boschetti, M., Nutini, F. et Busetto, L. (2020). sen2r: An R toolbox for automatically downloading and preprocessing Sentinel-2 satellite data. Computers & Geosciences, 139, 104473. https://doi.org/10.1016/j.cageo.2020.104473\n\n\nRead, J. S., Walker, J. I., Appling, A., Blodgett, D. L., Read, E. K. et Winslow, L. A. (2015). geoknife: Reproducible web-processing of large gridded datasets. Ecography. https://doi.org/10.1111/ecog.01880\n\n\nRecht, H. (2022). censusapi: Retrieve Data from the Census APIs. https://CRAN.R-project.org/package=censusapi\n\n\nRowlingson, B. (2019). geonames: Interface to the \"Geonames\" Spatial Query Web Service. https://CRAN.R-project.org/package=geonames\n\n\nSparks, A. H. (2018). nasapower: A NASA POWER Global Meteorology, Surface Solar Energy and Climatology Data Client for R. The Journal of Open Source Software, 3(30), 1035. https://doi.org/10.21105/joss.01035\n\n\nVargas, M. (2022). chilemapas: Mapas de las Divisiones Politicas y Administrativas de Chile (Maps of the Political and Administrative Divisions of Chile). https://CRAN.R-project.org/package=chilemapas\n\n\nWalker, K. (2021). idbr: R Interface to the US Census Bureau International Data Base API. https://CRAN.R-project.org/package=idbr\n\n\nWalker, K. (2023). tigris: Load Census TIGER/Line Shapefiles. https://CRAN.R-project.org/package=tigris\n\n\nWalker, K. et Herman, M. (2023). tidycensus: Load US Census Boundary and Attribute Data as ’tidyverse’ and ’sf’-Ready Data Frames. https://CRAN.R-project.org/package=tidycensus\n\n\nWatson, O. J., FitzJohn, R. et Eaton, J. W. (2019). rdhs: an R package to interact with The Demographic and Health Surveys (DHS) Program datasets. Wellcome Open Research, 4, 103. https://doi.org/10.12688/wellcomeopenres.15311.1\n\n\nWeidmann, N. B., Schvitz, G. et Girardin, L. (2021). cshapes: The CShapes 2.0 Dataset and Utilities. https://CRAN.R-project.org/package=cshapes",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2000_references.html",
    "href": "2000_references.html",
    "title": "References",
    "section": "",
    "text": "Agafonkin, V. (2015). JavaScript library for\nmobile-friendly interactive maps. https://github.com/Leaflet/Leaflet\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2023).\nmapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview\n\n\nAppelhans, T., Russell, K. et Busetto, L. (2020). mapedit:\nInteractive Editing of Spatial Data in R. https://CRAN.R-project.org/package=mapedit\n\n\nArel-Bundock, V. (2022). WDI: World Development Indicators and Other\nWorld Bank Data. https://CRAN.R-project.org/package=WDI\n\n\nAybar, C. (2023). rgee: R Bindings for Calling the ’Earth Engine’\nAPI. https://CRAN.R-project.org/package=rgee\n\n\nBivand, R. (2021). Progress in the R ecosystem for\nrepresenting and handling spatial data. Journal of Geographical\nSystems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for\nthe ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine\n- Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nBloch, M. (2013). Mapshaper: Tools for editing Shapefile, GeoJSON,\nTopoJSON and CSV files JavaScript libary. https://github.com/mbloch/mapshaper\n\n\nBocinsky, R. K. (2023). FedData: Functions to Automate Downloading\nGeospatial Data Available from Several Federated Data Sources. https://CRAN.R-project.org/package=FedData\n\n\nBusetto, L. et Ranghetti, L. (2016). MODIStsp: an R package for\npreprocessing of MODIS Land Products time series. Computers &\nGeosciences, 97, 40‑48. https://doi.org/10.1016/j.cageo.2016.08.020\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021).\ntidygeocoder: An R package for geocoding. Journal of Open Source\nSoftware, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nCarteron, P. (2023). happign: R Interface to ’IGN’ Web\nServices. https://CRAN.R-project.org/package=happign\n\n\nCheng, J., Schloerke, B., Karambelkar, B. et Xie, Y. (2023).\nleaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’\nLibrary. https://CRAN.R-project.org/package=leaflet\n\n\nDetomasi, R. (2023). geouy: Geographic Information of\nUruguay. https://github.com/RichDeto/geouy\n\n\nDyba, K. et Nowosad, J. (2021). rgugik: Search and Retrieve Spatial Data\nfrom the Polish Head Office of Geodesy and Cartography in R. Journal\nof Open Source Software, 6(59), 2948. https://doi.org/10.21105/joss.02948\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data\nAbstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://libgeos.org/\n\n\nGilardi, A. et Lovelace, R. (2023). osmextract: Download and Import\nOpen Street Map Data Extracts. https://CRAN.R-project.org/package=osmextract\n\n\nGiraud, T. (2022). osrm: Interface Between R and the\nOpenStreetMap-Based Routing Service OSRM. Journal of Open\nSource Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nGiraud, T. (2023a). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf\n\n\nGiraud, T. (2023b). maptiles: Download and Display Map Tiles.\nhttps://CRAN.R-project.org/package=maptiles\n\n\nGlenn, E. H. (2019). acs: Download, Manipulate, and Present American\nCommunity Survey and Decennial Data from the US Census. https://CRAN.R-project.org/package=acs\n\n\nGreg Freedman Ellis, Derek Burk et Finn Roberts. (2023). ipumsr: An\nR Interface for Downloading, Reading, and Handling IPUMS Data. https://CRAN.R-project.org/package=ipumsr\n\n\nHaukka, J. (2023). mapsFinland: Maps of Finland. https://CRAN.R-project.org/package=mapsFinland\n\n\nHernangómez, D. (2023a). giscoR: Download Map Data from\nGISCO API - Eurostat (version 0.4.0). https://doi.org/10.5281/zenodo.4317946\n\n\nHernangómez, D. (2023b). mapSpain: Administrative\nBoundaries of Spain (version 0.8.0). https://doi.org/10.5281/zenodo.5366622\n\n\nHijmans, R. J. (2023a). Spatial Data Science with R and\n\"terra\". https://rspatial.org\n\n\nHijmans, R. J. (2023b). terra: Spatial Data Analysis. https://CRAN.R-project.org/package=terra\n\n\nHijmans, R. J., Barbosa, M., Ghosh, A. et Mandel, A. (2023).\ngeodata: Download Geographic Data. https://CRAN.R-project.org/package=geodata\n\n\nHollister, J., Shah, T., Nowosad, J., Robitaille, A. L., Beck, M. W. et\nJohnson, M. (2023). elevatr: Access Elevation Data from Various\nAPIs. https://doi.org/10.5281/zenodo.8335450\n\n\nLahti, L., Huovari, J., Kainu, M. et Biecek, P. (2017). Retrieval and\nAnalysis of Eurostat Open Data with the eurostat Package. The R\nJournal, 9(1), 385‑392. https://doi.org/10.32614/RJ-2017-019\n\n\nLeclerc, H. (2022). insee: Tools to Easily Download Data from INSEE\nBDM Database. https://CRAN.R-project.org/package=insee\n\n\nLi, G. (2021). totalcensus: Extract Decennial Census and American\nCommunity Survey Data. https://CRAN.R-project.org/package=totalcensus\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar\nfields. https://slideplayer.com/slide/5822638/.\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation\nwith R. CRC Press. https://r.geocompx.org/\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap\ndata. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017).\nosmdata. Journal of Open Source Software, 2(14), 305.\nhttps://doi.org/10.21105/joss.00305\n\n\nMassicotte, P. et South, A. (2023). rnaturalearth: World Map Data\nfrom Natural Earth. https://CRAN.R-project.org/package=rnaturalearth\n\n\nMennis, J. (2015). Fundamentals of GIS : raster operations. https://cupdf.com/document/gus-0262-fundamentals-of-gis-lecture-presentation-7-raster-operations-jeremy.html.\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support\nfor Spatial Vector Data. The R Journal,\n10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data\nin R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With\napplications in R (p. 352). Chapman and\nHall/CRC. https://r-spatial.org/book/\n\n\nPebesma, E., Mailund, T. et Hiebert, J. (2016). Measurement Units in\nR. R Journal, 8(2), 486‑494. https://doi.org/10.32614/RJ-2016-061\n\n\nPereira, R. H. M. et Goncalves, C. N. (2023). geobr: Download\nOfficial Spatial Data Sets of Brazil. https://CRAN.R-project.org/package=geobr\n\n\nPiburn, J. (2020). wbstats: Programmatic Access to the World Bank\nAPI. Oak Ridge National Laboratory. https://doi.org/10.11578/dc.20171025.1827\n\n\nPROJ contributors. (2021). PROJ coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://proj.org/\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.\n\n\nRanghetti, L., Boschetti, M., Nutini, F. et Busetto, L. (2020). sen2r:\nAn R toolbox for automatically downloading and preprocessing Sentinel-2\nsatellite data. Computers & Geosciences, 139,\n104473. https://doi.org/10.1016/j.cageo.2020.104473\n\n\nRead, J. S., Walker, J. I., Appling, A., Blodgett, D. L., Read, E. K. et\nWinslow, L. A. (2015). geoknife: Reproducible web-processing of large\ngridded datasets. Ecography. https://doi.org/10.1111/ecog.01880\n\n\nRecht, H. (2022). censusapi: Retrieve Data from the Census\nAPIs. https://CRAN.R-project.org/package=censusapi\n\n\nRowlingson, B. (2019). geonames: Interface to the \"Geonames\" Spatial\nQuery Web Service. https://CRAN.R-project.org/package=geonames\n\n\nSparks, A. H. (2018). nasapower: A NASA POWER Global Meteorology,\nSurface Solar Energy and Climatology Data Client for R. The Journal\nof Open Source Software, 3(30), 1035. https://doi.org/10.21105/joss.01035\n\n\nTeucher, A. et Russell, K. (2023). rmapshaper: Client for\n’mapshaper’ for ’Geospatial’ Operations. https://CRAN.R-project.org/package=rmapshaper\n\n\nTomlin, C. D. (1990). Geographic information systems and\ncartographic modeling. Prentice Hall.\n\n\nVargas, M. (2022). chilemapas: Mapas de las Divisiones Politicas y\nAdministrativas de Chile (Maps of the Political and Administrative\nDivisions of Chile). https://CRAN.R-project.org/package=chilemapas\n\n\nWalker, K. (2021). idbr: R Interface to the US Census Bureau\nInternational Data Base API. https://CRAN.R-project.org/package=idbr\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference\nSystem Information for Spatial Data. https://CRAN.R-project.org/package=crsuggest\n\n\nWalker, K. (2023). tigris: Load Census TIGER/Line Shapefiles.\nhttps://CRAN.R-project.org/package=tigris\n\n\nWalker, K. et Herman, M. (2023). tidycensus: Load US Census Boundary\nand Attribute Data as ’tidyverse’ and ’sf’-Ready Data Frames. https://CRAN.R-project.org/package=tidycensus\n\n\nWatson, O. J., FitzJohn, R. et Eaton, J. W. (2019). rdhs: an R package\nto interact with The Demographic and Health Surveys (DHS) Program\ndatasets. Wellcome Open Research, 4, 103. https://doi.org/10.12688/wellcomeopenres.15311.1\n\n\nWeidmann, N. B., Schvitz, G. et Girardin, L. (2021). cshapes: The\nCShapes 2.0 Dataset and Utilities. https://CRAN.R-project.org/package=cshapes\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et\nal.Yutani, H. (2019). Welcome to the tidyverse.\nJournal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "2002_data.html",
    "href": "2002_data.html",
    "title": "Annexe A — Les données du projet",
    "section": "",
    "text": "Les données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\n lot.gpkg\nCe fichier contient plusieurs couches d’informations.\n\ndepartements : les départements français métropolitains, Admin Express COG Carto 3.0, IGN - 2021;\ncommunes : les communes du département du Lot (46) avec des données sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, BD CARTO® 4.0, IGN - 2021 & Recensements harmonisés - Séries départementales et communales, INSEE - 2020;\nroutes : les routes de la commune de Gramat et alentours (46128), BD CARTO® 4.0, IGN - 2021;\nrestaurants : les restaurants du Lot, Base permanente des équipements (BPE), INSEE - 2021;\nelevations : une grille régulière de points d’altitude (pas d’1 km), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT).\n\n com.csv\nCe fichier tabulaire contient des informations complémentaires sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, Recensements harmonisés - Séries départementales et communales, INSEE - 2020.\n\nle nombre d’actifs (ACT);\nle nombre d’actifs dans l’industrie (IND);\nla part des actifs dans la population totale (SACT);\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND).\n\n elevation.tif\nUne grille régulière de points d’altitude (pas de 30 mètres environ), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT).\nelev.tif est une version reprojetée en Lambert 93 de elevation.tif\n clc_2018.tif\nDonnées CORINE Land Cover, Corine Land Cover (CLC) 2018, Version 2020_20u1 - Copernicus Programme.\nclc.tif est une version reprojetée en Lambert 93 de clc_2018.tif\n Sentinel2A.tif\nDonnées Sentinel, Sentinel, Sentinel-2A, S2A_OPER_MSI_L2A_DS_VGS2_20211012T140548_S20211012T105447_N03.01, 12 Octobre 2021 - Copernicus Programme, téléchargées le 28 décembre 2021.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Les données du projet</span>"
    ]
  }
]